import { NhostClient as L, addSecurityKeyPromise as M, createChangeEmailMachine as N, changeEmailPromise as R, createChangePasswordMachine as K, changePasswordPromise as V, createEnableMfaMachine as D, generateQrCodePromise as F, activateMfaPromise as _, createFileUploadMachine as q, uploadFilePromise as H, createMultipleFilesUploadMachine as Q, uploadMultipleFilesPromise as $, encodeQueryParameters as j, rewriteRedirectTo as G, createResetPasswordMachine as J, resetPasswordPromise as Y, createSendVerificationEmailMachine as W, sendVerificationEmailPromise as z, signInAnonymousPromise as B, signInEmailPasswordPromise as X, signInMfaTotpPromise as Z, signInEmailPasswordlessPromise as b, signInEmailSecurityKeyPromise as ee, elevateEmailSecurityKeyPromise as te, signInPATPromise as se, signInSmsPasswordlessPromise as ne, signInSmsPasswordlessOtpPromise as k, signOutPromise as oe, signUpEmailPasswordPromise as re, signUpEmailSecurityKeyPromise as ce } from "@nhost/nhost-js";
import { NHOST_REFRESH_TOKEN_KEY as st } from "@nhost/nhost-js";
import ie, { createContext as ae, useRef as ue, useEffect as y, useContext as T, createElement as w, Fragment as A, useState as x, useMemo as P, useCallback as le } from "react";
import { useInterpret as v, useSelector as s } from "@xstate/react";
import { jwtDecode as de } from "jwt-decode";
const he = L;
class Pe extends he {
  constructor(t) {
    super({ ...t, start: !1 });
  }
}
const I = ae({}), me = ({
  nhost: e,
  initial: t,
  ...n
}) => {
  const c = v(e.auth.client.machine, { devTools: e.devTools });
  e.auth.client.start({ interpreter: c, initialSession: t, devTools: e.devTools });
  const m = ue(!0);
  return y(() => {
    m.current ? m.current = !1 : t && c.send("SESSION_UPDATE", { data: { session: t } });
  }, [t, c]), /* @__PURE__ */ ie.createElement(I.Provider, { value: e }, n.children);
}, ye = me, E = () => {
  var n;
  const t = (n = T(I).auth) == null ? void 0 : n.client.interpreter;
  if (!t)
    throw Error("Could not find the Nhost auth client. Did you wrap your app in <NhostProvider />?");
  return t;
}, U = () => {
  const e = E();
  return s(
    e,
    (t) => ({
      isAuthenticated: t.matches({ authentication: "signedIn" }),
      isLoading: t.hasTag("loading"),
      error: t.context.errors.authentication || null,
      isError: t.matches({ authentication: { signedOut: "failed" } }),
      connectionAttempts: t.context.importTokenAttempts
    }),
    (t, n) => t.isAuthenticated === n.isAuthenticated && t.isLoading === n.isLoading && t.connectionAttempts === n.connectionAttempts
  );
};
function Ie({ children: e }) {
  const { isAuthenticated: t } = U();
  return t ? w(A, null, e) : null;
}
function Te({ children: e }) {
  const { isAuthenticated: t } = U();
  return t ? null : w(A, null, e);
}
const O = () => {
  const e = E();
  return s(e, (t) => t.context.accessToken.value);
}, f = () => T(I), ke = () => {
  const e = f(), [t, n] = x(null), c = !t, m = !!t, [d, g] = x(!1);
  return { add: async (u) => {
    g(!0);
    const r = await M(e.auth.client, u), { error: i } = r;
    return i && n(i), g(!1), r;
  }, isLoading: d, isSuccess: c, isError: m, error: t };
}, we = () => {
  const e = E(), [t, n] = x(
    !!e.status && e.getSnapshot().matches({ authentication: "signedIn" })
  );
  return y(() => e.subscribe((m) => {
    const d = m.matches({ authentication: "signedIn" });
    n(d);
  }).unsubscribe, [e]), t;
};
function Ae(e) {
  const t = f(), n = P(() => N(t.auth.client), [t]), c = v(n), m = s(c, (r) => r.matches("requesting")), d = s(c, (r) => r.context.error), g = s(c, (r) => r.matches("idle.error")), h = s(c, (r) => r.matches("idle.success"));
  return { changeEmail: le(
    async (r, i = e) => R(c, r, i),
    [c, e]
  ), isLoading: m, needsEmailVerification: h, isError: g, error: d };
}
const Ue = () => {
  const e = f(), t = P(() => K(e.auth.client), [e]), n = v(t), c = s(n, (u) => u.matches({ idle: "error" })), m = s(n, (u) => u.matches({ idle: "success" })), d = s(n, (u) => u.context.error), g = s(n, (u) => u.matches("requesting"));
  return { changePassword: (u) => V(n, u), isLoading: g, isSuccess: m, isError: c, error: d };
}, Oe = () => {
  const e = f(), t = P(() => D(e.auth.client), [e]), n = v(t), c = s(
    n,
    (l) => l.matches({ idle: "error" }) || l.matches({ generated: { idle: "error" } })
  ), m = s(n, (l) => l.matches("generating")), d = s(n, (l) => l.matches("generated")), g = s(n, (l) => l.matches({ generated: "activating" })), h = s(n, (l) => l.matches({ generated: "activated" })), u = s(n, (l) => l.context.error), r = s(n, (l) => l.context.imageUrl || "");
  return {
    generateQrCode: () => F(n),
    isGenerating: m,
    qrCodeDataUrl: r,
    isGenerated: d,
    activateMfa: (l) => _(n, l),
    isActivating: g,
    isActivated: h,
    isError: c,
    error: u
  };
}, ge = () => {
  const e = O();
  return e ? de(e) : null;
}, pe = (e) => {
  const t = f(), n = (p) => {
    e.send({
      type: "ADD",
      file: p.file,
      bucketId: p.bucketId || l
    });
  }, c = (p) => H(
    {
      url: t.storage.url,
      accessToken: t.auth.getAccessToken(),
      adminSecret: t.adminSecret,
      ...p
    },
    e
  ), m = () => {
    e.send("CANCEL");
  }, d = () => {
    e.send("DESTROY");
  }, g = s(e, (p) => p.matches("uploading")), h = s(e, (p) => p.matches("uploaded")), u = s(e, (p) => p.matches("error")), r = s(e, (p) => p.context.error || null), i = s(e, (p) => p.context.progress), o = s(e, (p) => p.context.id), l = s(e, (p) => p.context.bucketId), a = s(e, (p) => {
    var S;
    return (S = p.context.file) == null ? void 0 : S.name;
  });
  return {
    add: n,
    upload: c,
    cancel: m,
    destroy: d,
    isUploaded: h,
    isUploading: g,
    isError: u,
    error: r,
    progress: i,
    id: o,
    bucketId: l,
    name: a
  };
}, Ce = () => {
  const e = v(q);
  return pe(e);
}, C = () => {
  const e = ge();
  return (e == null ? void 0 : e["https://hasura.io/jwt/claims"]) || null;
}, Le = (e) => {
  const t = C();
  return (t == null ? void 0 : t[e.startsWith("x-hasura-") ? e : `x-hasura-${e}`]) || null;
}, Me = () => {
  const e = f(), [t, n] = x([]), c = v(Q, {}, (a) => {
    a.event.type === "UPLOAD_ERROR" ? n(a.context.files.filter((p) => {
      var S;
      return (S = p.getSnapshot()) == null ? void 0 : S.context.error;
    })) : (a.matches("uploaded") || a.event.type === "CLEAR") && t.length > 0 && n([]);
  }), m = (a) => {
    c.send({ type: "ADD", ...a });
  }, d = (a) => $(
    {
      url: e.storage.url,
      accessToken: e.auth.getAccessToken(),
      adminSecret: e.adminSecret,
      ...a
    },
    c
  ), g = () => {
    c.send("CANCEL");
  }, h = () => {
    c.send("CLEAR");
  }, u = s(c, (a) => a.matches("uploading")), r = s(c, (a) => a.matches("uploaded")), i = s(c, (a) => a.matches("error")), o = s(c, (a) => a.context.progress), l = s(c, (a) => a.context.files);
  return {
    upload: d,
    add: m,
    clear: h,
    cancel: g,
    progress: o,
    isUploaded: r,
    isUploading: u,
    files: l,
    isError: i,
    errors: t
  };
}, Ne = (e) => {
  const [t, n] = x(!0), c = O();
  y(() => {
    n(!1);
  }, []);
  const m = T(I);
  return new Proxy({}, {
    get(d, g) {
      let h = `${m.auth.client.backendUrl}/signin/provider/${g}`;
      const u = e != null && e.connect ? { connect: c } : {};
      return j(
        h,
        G(t ? void 0 : m.auth.client.clientUrl, {
          ...e,
          ...u
        })
      );
    }
  });
}, Re = (e) => {
  const t = f(), n = P(() => J(t.auth.client), [t]), c = v(n), m = s(c, (r) => r.matches("requesting")), d = s(c, (r) => r.context.error), g = s(c, (r) => r.matches("idle.error")), h = s(c, (r) => r.matches("idle.success"));
  return { resetPassword: (r, i = e) => Y(c, r, i), isLoading: m, isSent: h, isError: g, error: d };
}, Ke = (e) => {
  const t = f(), n = P(() => W(t.auth.client), [t]), c = v(n), m = s(c, (r) => r.matches({ idle: "error" })), d = s(c, (r) => r.matches({ idle: "success" })), g = s(c, (r) => r.context.error), h = s(c, (r) => r.matches("requesting"));
  return { sendEmail: (r, i = e) => z(c, r, i), isLoading: h, isSent: d, isError: m, error: g };
}, Ve = () => {
  const e = E(), t = () => B(e), n = s(
    e,
    (u) => u.context.errors.authentication || null,
    (u, r) => (u == null ? void 0 : u.error) === (r == null ? void 0 : r.error)
  ), c = s(
    e,
    (u) => u.matches({ authentication: { authenticating: "anonymous" } })
  ), m = s(
    e,
    (u) => u.matches({
      authentication: "signedIn"
    })
  ), d = s(
    e,
    (u) => u.matches({ authentication: { signedOut: "failed" } })
  ), g = s(
    e,
    (u) => u.context.user,
    (u, r) => (u == null ? void 0 : u.id) === (r == null ? void 0 : r.id)
  );
  return { accessToken: s(e, (u) => u.context.accessToken.value), error: n, isError: d, isLoading: c, isSuccess: m, signInAnonymous: t, user: g };
}, De = () => {
  const e = E(), t = (a, p) => X(e, a, p), n = (a) => Z(e, a), c = s(
    e,
    (a) => a.context.user,
    (a, p) => (a == null ? void 0 : a.id) === (p == null ? void 0 : p.id)
  ), m = s(e, (a) => a.context.accessToken.value), d = s(e, (a) => a.context.refreshToken.value), g = s(
    e,
    (a) => a.context.errors.authentication || null,
    (a, p) => (a == null ? void 0 : a.error) === (p == null ? void 0 : p.error)
  ), h = s(
    e,
    (a) => a.matches({
      authentication: "signedIn"
    })
  ), u = s(
    e,
    (a) => a.matches({ authentication: { authenticating: "password" } }),
    (a, p) => a === p
  ), r = s(
    e,
    (a) => a.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (a, p) => a === p
  ), i = s(
    e,
    (a) => a.matches({ authentication: { signedOut: "needsMfa" } }),
    (a, p) => a === p
  ), o = s(
    e,
    (a) => a.matches({ authentication: { signedOut: "failed" } }),
    (a, p) => a === p
  ), l = s(e, (a) => a.context.mfa);
  return {
    accessToken: m,
    refreshToken: d,
    error: g,
    isError: o,
    isLoading: u,
    isSuccess: h,
    needsEmailVerification: r,
    needsMfaOtp: i,
    mfa: l,
    sendMfaOtp: n,
    signInEmailPassword: t,
    user: c
  };
};
function Fe(e) {
  const t = E(), n = (h, u = e) => b(t, h, u), c = s(
    t,
    (h) => h.context.errors.registration || null,
    (h, u) => (h == null ? void 0 : h.error) === (u == null ? void 0 : u.error)
  ), m = s(t, (h) => h.matches("registration.passwordlessEmail")), d = s(
    t,
    (h) => h.matches("registration.incomplete.needsEmailVerification")
  ), g = s(t, (h) => h.matches("registration.incomplete.failed"));
  return { signInEmailPasswordless: n, isLoading: m, isSuccess: d, isError: g, error: c };
}
const _e = () => {
  const e = E(), t = (i) => ee(e, i), n = s(
    e,
    (i) => i.context.user,
    (i, o) => (i == null ? void 0 : i.id) === (o == null ? void 0 : o.id)
  ), c = s(e, (i) => i.context.accessToken.value), m = s(e, (i) => i.context.refreshToken.value), d = s(
    e,
    (i) => i.context.errors.authentication || null,
    (i, o) => (i == null ? void 0 : i.error) === (o == null ? void 0 : o.error)
  ), g = s(
    e,
    (i) => i.matches({
      authentication: "signedIn"
    })
  ), h = s(
    e,
    (i) => i.matches({ authentication: { authenticating: "securityKeyEmail" } }),
    (i, o) => i === o
  ), u = s(
    e,
    (i) => i.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (i, o) => i === o
  ), r = s(
    e,
    (i) => i.matches({ authentication: { signedOut: "failed" } }),
    (i, o) => i === o
  );
  return {
    accessToken: c,
    refreshToken: m,
    error: d,
    isError: r,
    isLoading: h,
    isSuccess: g,
    needsEmailVerification: u,
    signInEmailSecurityKey: t,
    user: n
  };
}, Ee = () => {
  const e = E();
  return s(
    e,
    (t) => t.context.user,
    (t, n) => (t && JSON.stringify(t)) === (n && JSON.stringify(n))
  );
}, qe = () => {
  const e = Ee(), t = f(), n = C(), c = e ? (n == null ? void 0 : n["x-hasura-auth-elevated"]) === (e == null ? void 0 : e.id) : !1, [m, d] = x(!!c), g = (h) => te(t.auth.client, h);
  return y(() => {
    d(!!c);
  }, [c]), {
    elevated: m,
    elevateEmailSecurityKey: g
  };
}, He = () => {
  const e = E(), t = (r) => se(e, r), n = s(
    e,
    (r) => r.context.user,
    (r, i) => (r == null ? void 0 : r.id) === (i == null ? void 0 : i.id)
  ), c = s(e, (r) => r.context.accessToken.value), m = s(e, (r) => r.context.refreshToken.value), d = s(
    e,
    (r) => r.context.errors.authentication || null,
    (r, i) => (r == null ? void 0 : r.error) === (i == null ? void 0 : i.error)
  ), g = s(e, (r) => r.matches({ authentication: "signedIn" })), h = s(
    e,
    (r) => r.matches({ authentication: { authenticating: "password" } }),
    (r, i) => r === i
  ), u = s(
    e,
    (r) => r.matches({ authentication: { signedOut: "failed" } }),
    (r, i) => r === i
  );
  return {
    accessToken: c,
    refreshToken: m,
    error: d,
    isError: u,
    isLoading: h,
    isSuccess: g,
    signInPAT: t,
    user: n
  };
};
function Qe(e) {
  const t = E(), [n, c] = x(""), m = (o, l = e) => (c(o), ne(t, o, l)), d = async (...o) => {
    if (o.length === 2) {
      const [a, p] = o;
      return k(t, a, p);
    }
    const [l] = o;
    return k(t, n, l);
  }, g = s(
    t,
    (o) => o.context.errors.registration || null,
    (o, l) => (o == null ? void 0 : o.error) === (l == null ? void 0 : l.error)
  ), h = s(
    t,
    (o) => o.matches("registration.passwordlessSms") || o.matches("registration.passwordlessSmsOtp")
  ), u = s(t, (o) => o.matches("authentication.signedIn")), r = s(
    t,
    (o) => o.matches("registration.incomplete.needsOtp")
  ), i = s(t, (o) => o.matches("registration.incomplete.failed"));
  return { signInSmsPasswordless: m, sendOtp: d, isLoading: h, isSuccess: u, needsOtp: r, isError: i, error: g };
}
const $e = (e = !1) => {
  const t = E(), n = (d) => oe(t, typeof d == "boolean" ? d : e), c = s(
    t,
    (d) => d.matches({ authentication: { signedOut: "success" } }),
    (d, g) => d === g
  ), m = s(
    t,
    (d) => d.context.errors.signout || null,
    (d, g) => (d == null ? void 0 : d.error) === (g == null ? void 0 : g.error)
  );
  return { signOut: n, isSuccess: c, error: m };
}, je = (e) => {
  const t = E(), n = s(t, (o) => !!o.context.errors.registration), c = s(
    t,
    (o) => o.context.errors.registration || null,
    (o, l) => (o == null ? void 0 : o.error) === (l == null ? void 0 : l.error)
  ), m = s(t, (o) => o.matches("registration.emailPassword")), d = s(
    t,
    (o) => o.matches("registration.incomplete.needsEmailVerification")
  ), g = s(
    t,
    (o) => o.matches({
      authentication: "signedIn",
      registration: "complete"
    })
  ), h = (o, l, a = e) => re(t, o, l, a), u = s(
    t,
    (o) => o.context.user,
    (o, l) => (o == null ? void 0 : o.id) === (l == null ? void 0 : l.id)
  ), r = s(t, (o) => o.context.accessToken.value), i = s(t, (o) => o.context.refreshToken.value);
  return {
    accessToken: r,
    refreshToken: i,
    error: c,
    isError: n,
    isLoading: m,
    isSuccess: g,
    needsEmailVerification: d,
    signUpEmailPassword: h,
    user: u
  };
}, Ge = (e) => {
  const t = E(), n = s(t, (o) => !!o.context.errors.registration), c = s(
    t,
    (o) => o.context.errors.registration || null,
    (o, l) => (o == null ? void 0 : o.error) === (l == null ? void 0 : l.error)
  ), m = s(t, (o) => o.matches("registration.securityKey")), d = s(
    t,
    (o) => o.matches("registration.incomplete.needsEmailVerification")
  ), g = s(
    t,
    (o) => o.matches({
      authentication: "signedIn",
      registration: "complete"
    })
  ), h = (o, l = e) => ce(t, o, l), u = s(
    t,
    (o) => o.context.user,
    (o, l) => (o == null ? void 0 : o.id) === (l == null ? void 0 : l.id)
  ), r = s(t, (o) => o.context.accessToken.value), i = s(t, (o) => o.context.refreshToken.value);
  return {
    accessToken: r,
    refreshToken: i,
    error: c,
    isError: n,
    isLoading: m,
    isSuccess: g,
    needsEmailVerification: d,
    signUpEmailSecurityKey: h,
    user: u
  };
}, Je = () => {
  const e = E();
  return s(
    e,
    (t) => {
      var n;
      return (n = t.context.user) == null ? void 0 : n.avatarUrl;
    },
    (t, n) => t === n
  );
}, Ye = () => {
  const e = E();
  return s(
    e,
    (t) => {
      var n;
      return (n = t.context.user) == null ? void 0 : n.defaultRole;
    },
    (t, n) => t === n
  );
}, We = () => {
  const e = E();
  return s(
    e,
    (t) => {
      var n;
      return (n = t.context.user) == null ? void 0 : n.displayName;
    },
    (t, n) => t === n
  );
}, ze = () => {
  const e = E();
  return s(
    e,
    (t) => {
      var n;
      return (n = t.context.user) == null ? void 0 : n.email;
    },
    (t, n) => t === n
  );
}, Be = () => {
  const e = E();
  return s(
    e,
    (t) => {
      var n;
      return (n = t.context.user) == null ? void 0 : n.id;
    },
    (t, n) => t === n
  );
}, Xe = () => {
  const e = E();
  return s(
    e,
    (t) => {
      var n;
      return (n = t.context.user) == null ? void 0 : n.isAnonymous;
    },
    (t, n) => t === n
  );
}, Ze = () => {
  const e = E();
  return s(
    e,
    (t) => {
      var n;
      return (n = t.context.user) == null ? void 0 : n.locale;
    },
    (t, n) => t === n
  );
}, be = () => {
  const e = E();
  return s(e, (t) => {
    var n;
    return t.matches("authentication.signedIn") ? ((n = t.context.user) == null ? void 0 : n.roles) || [] : [];
  });
};
export {
  st as NHOST_REFRESH_TOKEN_KEY,
  Pe as NhostClient,
  me as NhostProvider,
  I as NhostReactContext,
  ye as NhostReactProvider,
  Ie as SignedIn,
  Te as SignedOut,
  he as VanillaNhostClient,
  O as useAccessToken,
  ke as useAddSecurityKey,
  E as useAuthInterpreter,
  we as useAuthenticated,
  U as useAuthenticationStatus,
  Ae as useChangeEmail,
  Ue as useChangePassword,
  Oe as useConfigMfa,
  ge as useDecodedAccessToken,
  qe as useElevateSecurityKeyEmail,
  Ce as useFileUpload,
  pe as useFileUploadItem,
  Le as useHasuraClaim,
  C as useHasuraClaims,
  Me as useMultipleFilesUpload,
  f as useNhostClient,
  Ne as useProviderLink,
  Re as useResetPassword,
  Ke as useSendVerificationEmail,
  Ve as useSignInAnonymous,
  De as useSignInEmailPassword,
  Fe as useSignInEmailPasswordless,
  _e as useSignInEmailSecurityKey,
  He as useSignInPAT,
  Qe as useSignInSmsPasswordless,
  $e as useSignOut,
  je as useSignUpEmailPassword,
  Ge as useSignUpEmailSecurityKeyEmail,
  Je as useUserAvatarUrl,
  Ee as useUserData,
  Ye as useUserDefaultRole,
  We as useUserDisplayName,
  ze as useUserEmail,
  Be as useUserId,
  Xe as useUserIsAnonymous,
  Ze as useUserLocale,
  be as useUserRoles
};
//# sourceMappingURL=index.esm.js.map
