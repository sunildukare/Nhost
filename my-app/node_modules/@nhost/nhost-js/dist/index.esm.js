import { HasuraAuthClient as g } from "@nhost/hasura-auth-js";
export * from "@nhost/hasura-auth-js";
import { HasuraStorageClient as p } from "@nhost/hasura-storage-js";
export * from "@nhost/hasura-storage-js";
import T from "isomorphic-unfetch";
import { NhostGraphqlClient as m } from "@nhost/graphql-js";
const w = /^((?<protocol>http[s]?):\/\/)?(?<host>(localhost|local))(:(?<port>(\d+|__\w+__)))?$/;
function d(e, t) {
  const { subdomain: r, region: n } = e;
  if (!r)
    throw new Error("A `subdomain` must be set.");
  const h = r.match(w);
  if (h != null && h.groups) {
    const { protocol: c, host: a, port: u } = h.groups, s = b(t);
    return s || (a === "localhost" ? (console.warn(
      'The `subdomain` is set to "localhost". Support for this will be removed in a future release. Please use "local" instead.'
    ), `${c || "http"}://localhost:${u || 1337}/v1/${t}`) : u ? `${c || "https"}://local.${t}.nhost.run:${u}/v1` : `${c || "https"}://local.${t}.nhost.run/v1`);
  }
  if (!n)
    throw new Error('`region` must be set when using a `subdomain` other than "local".');
  return `https://${r}.${t}.${n}.nhost.run/v1`;
}
function k() {
  return typeof window != "undefined";
}
function A() {
  return typeof process != "undefined" && process.env;
}
function b(e) {
  return k() || !A() ? null : process.env[`NHOST_${e.toUpperCase()}_URL`];
}
function S(e, t) {
  const n = t.startsWith("/") ? t : `/${t}`;
  return e + n;
}
function H(e) {
  const t = "subdomain" in e ? d(e, "auth") : e.authUrl;
  if (!t)
    throw new Error("Please provide `subdomain` or `authUrl`.");
  return new g({ url: t, ...e });
}
function x(e) {
  const t = "subdomain" in e ? d(e, "functions") : e.functionsUrl;
  if (!t)
    throw new Error("Please provide `subdomain` or `functionsUrl`.");
  return new U({ url: t, ...e });
}
class U {
  constructor(t) {
    this.headers = {};
    const { url: r, adminSecret: n } = t;
    this.url = r, this.accessToken = null, this.adminSecret = n;
  }
  /**
   * Use `nhost.functions.call` to call (sending a POST request to) a serverless function. Use generic
   * types to specify the expected response data, request body and error message.
   *
   * @example
   * ### Without generic types
   * ```ts
   * await nhost.functions.call('send-welcome-email', { email: 'joe@example.com', name: 'Joe Doe' })
   * ```
   *
   * @example
   * ### Using generic types
   * ```ts
   * type Data = {
   *   message: string
   * }
   *
   * type Body = {
   *   email: string
   *   name: string
   * }
   *
   * type ErrorMessage = {
   *   details: string
   * }
   *
   * // The function will only accept a body of type `Body`
   * const { res, error } = await nhost.functions.call<Data, Body, ErrorMessage>(
   *   'send-welcome-email',
   *   { email: 'joe@example.com', name: 'Joe Doe' }
   * )
   *
   * // Now the response data is typed as `Data`
   * console.log(res?.data.message)
   *
   * // Now the error message is typed as `ErrorMessage`
   * console.log(error?.message.details)
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/nhost-js/functions/call
   */
  async call(t, r, n) {
    var a, u;
    const h = {
      "Content-Type": "application/json",
      ...this.generateAccessTokenHeaders(),
      ...n == null ? void 0 : n.headers,
      ...this.headers
      // nhost functions client headers to be sent with all calls
    }, c = S(this.url, t);
    try {
      const s = await T(c, {
        body: r ? JSON.stringify(r) : null,
        headers: h,
        method: "POST"
      });
      if (!s.ok) {
        let i;
        return (a = s.headers.get("content-type")) != null && a.includes("application/json") ? i = await s.json() : i = await s.text(), {
          res: null,
          error: {
            message: i,
            error: s.statusText,
            status: s.status
          }
        };
      }
      let o;
      return (u = s.headers.get("content-type")) != null && u.includes("application/json") ? o = await s.json() : o = await s.text(), {
        res: { data: o, status: s.status, statusText: s.statusText },
        error: null
      };
    } catch (s) {
      const o = s;
      return {
        res: null,
        error: {
          message: o.message,
          status: o.name === "AbortError" ? 0 : 500,
          error: o.name === "AbortError" ? "abort-error" : "unknown"
        }
      };
    }
  }
  /**
   * Use `nhost.functions.setAccessToken` to a set an access token to be used in subsequent functions requests. Note that if you're signin in users with `nhost.auth.signIn()` the access token will be set automatically.
   *
   * @example
   * ```ts
   * nhost.functions.setAccessToken('some-access-token')
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/nhost-js/functions/set-access-token
   */
  setAccessToken(t) {
    if (!t) {
      this.accessToken = null;
      return;
    }
    this.accessToken = t;
  }
  /**
   * Use `nhost.functions.getHeaders` to get the global headers sent with all functions requests.
   *
   * @example
   * ```ts
   * nhost.functions.getHeaders()
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/nhost-js/functions/get-headers
   */
  getHeaders() {
    return this.headers;
  }
  /**
   * Use `nhost.functions.setHeaders` to a set global headers to be sent in all subsequent functions requests.
   *
   * @example
   * ```ts
   * nhost.functions.setHeaders({
   *  'x-hasura-role': 'admin'
   * })
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/nhost-js/functions/set-headers
   */
  setHeaders(t) {
    t && (this.headers = {
      ...this.headers,
      ...t
    });
  }
  /**
   * Use `nhost.functions.unsetHeaders` to a unset global headers sent with all functions requests.
   *
   * @example
   * ```ts
   * nhost.functions.unsetHeaders()
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/nhost-js/functions/unset-headers
   */
  unsetHeaders() {
    const t = this.headers["x-hasura-role"];
    this.headers = t ? { "x-hasura-role": t } : {};
  }
  generateAccessTokenHeaders() {
    return this.adminSecret ? {
      "x-hasura-admin-secret": this.adminSecret
    } : this.accessToken ? {
      Authorization: `Bearer ${this.accessToken}`
    } : {};
  }
}
function v(e) {
  const t = "subdomain" in e ? d(e, "graphql") : e.graphqlUrl;
  if (!t)
    throw new Error("Please provide `subdomain` or `graphqlUrl`.");
  return new m({ url: t, ...e });
}
function C(e) {
  const t = "subdomain" in e ? d(e, "storage") : e.storageUrl;
  if (!t)
    throw new Error("Please provide `subdomain` or `storageUrl`.");
  return new p({ url: t, ...e });
}
const N = (e) => new $(e);
class $ {
  /**
   *
   * @example
   * ```ts
   * // Create a new Nhost client from subdomain and region.
   * const nhost = new NhostClient({ subdomain, region });
   * ```
   *
   *
   * ```ts
   * // Create a new Nhost client from individual service URLs (custom domains, self-hosting, etc).
   * const nhost = new NhostClient({ 
   *   authUrl: "my-auth-service-url",
   *   storageUrl: "my-storage-service-url",
   *   graphqlUrl: "my-graphql-service-url",
   *   functionsUrl: "my-functions-service-url",
   * });
   * ```
   *
   *
   * ```ts
   * // Create a new Nhost client for local development.
   * const nhost = new NhostClient({ subdomain: "local" });
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript
   */
  constructor({
    refreshIntervalTime: t,
    clientStorage: r,
    clientStorageType: n,
    autoRefreshToken: h,
    autoSignIn: c,
    adminSecret: a,
    devTools: u,
    start: s = !0,
    ...o
  }) {
    this.auth = H({
      refreshIntervalTime: t,
      clientStorage: r,
      clientStorageType: n,
      autoRefreshToken: h,
      autoSignIn: c,
      start: s,
      ...o
    }), this.storage = C({ adminSecret: a, ...o }), this.functions = x({ adminSecret: a, ...o }), this.graphql = v({ adminSecret: a, ...o }), this.auth.onAuthStateChanged((i, l) => {
      if (i === "SIGNED_OUT") {
        this.storage.setAccessToken(void 0), this.functions.setAccessToken(void 0), this.graphql.setAccessToken(void 0);
        return;
      }
      const f = l == null ? void 0 : l.accessToken;
      this.storage.setAccessToken(f), this.functions.setAccessToken(f), this.graphql.setAccessToken(f);
    }), this.auth.onTokenChanged((i) => {
      const l = i == null ? void 0 : i.accessToken;
      this.storage.setAccessToken(l), this.functions.setAccessToken(l), this.graphql.setAccessToken(l);
    }), this._adminSecret = a, this.devTools = u;
  }
  get adminSecret() {
    return this._adminSecret;
  }
  set adminSecret(t) {
    this._adminSecret = t, this.storage.setAdminSecret(t);
  }
  /**
   * Use `nhost.setRole` to set the user role for all subsequent GraphQL, storage, and functions calls.
   * Underneath, this method sets the `x-hasura-role` header on the graphql, storage,
   * and functions clients.
   *
   * ```ts
   * nhost.graphql.setHeaders({ 'x-hasura-role': role })
   * nhost.storage.setHeaders({ 'x-hasura-role': role })
   * nhost.functions.setHeaders({ 'x-hasura-role': role })
   * ```
   *
   * Note: Exercise caution when mixing the use of `setRole` along with `setHeaders` when setting the
   * `x-hasura-role` header, as the last call will override any previous ones.
   *
   * @example
   * ```ts
   * nhost.setRole('admin')
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/nhost-js/set-role
   */
  setRole(t) {
    this.graphql.setHeaders({ "x-hasura-role": t }), this.storage.setHeaders({ "x-hasura-role": t }), this.functions.setHeaders({ "x-hasura-role": t });
  }
  /**
   * Use `nhost.unsetRole` to unset the user role for all subsequent graphql, storage and functions calls.
   * Underneath, this method removes the `x-hasura-role` header from the graphql, storage and functions clients.
   *
   * Note: Exercise caution when mixing the use of `unsetRole` along with `setHeaders` when setting the
   * `x-hasura-role` header, as the last call will override any previous ones.
   *
   * @example
   * ```ts
   * nhost.unsetRole()
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/nhost-js/unset-role
   */
  unsetRole() {
    this.graphql.setHeaders((({ "x-hasura-role": t, ...r }) => r)(this.graphql.getHeaders())), this.storage.setHeaders((({ "x-hasura-role": t, ...r }) => r)(this.storage.getHeaders())), this.functions.setHeaders(
      (({ "x-hasura-role": t, ...r }) => r)(this.functions.getHeaders())
    );
  }
}
export {
  $ as NhostClient,
  U as NhostFunctionsClient,
  H as createAuthClient,
  x as createFunctionsClient,
  v as createGraphqlClient,
  N as createNhostClient,
  C as createStorageClient,
  d as urlFromSubdomain
};
//# sourceMappingURL=index.esm.js.map
