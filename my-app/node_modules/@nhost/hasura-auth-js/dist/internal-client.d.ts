import { AuthContext, AuthInterpreter, AuthMachineOptions } from './machines';
import { NhostSession } from './types';

export type NhostClientOptions = AuthMachineOptions & {
    /** @internal create and start xstate interpreter on creation. With React, it is started inside the Nhost provider */
    start?: boolean;
};
/**
 * @internal
 * This is a private API.
 */
export declare class AuthClient {
    readonly backendUrl: string;
    readonly clientUrl: string;
    private _machine;
    private _interpreter?;
    private _started;
    private _channel?;
    private _subscriptionsQueue;
    private _subscriptions;
    constructor({ clientStorageType, autoSignIn, autoRefreshToken, start, backendUrl, clientUrl, devTools, ...defaultOptions }: NhostClientOptions);
    start({ devTools, initialSession, interpreter }?: {
        interpreter?: AuthInterpreter;
        initialSession?: NhostSession;
        devTools?: boolean;
    }): void;
    get machine(): import('xstate').StateMachine<AuthContext, any, {
        type: "SESSION_UPDATE";
        data: {
            session: NhostSession;
        };
    } | {
        type: "TRY_TOKEN";
        token: string;
    } | {
        type: "SIGNIN_ANONYMOUS";
    } | {
        type: "SIGNIN_PAT";
        pat: string;
    } | {
        type: "SIGNIN_SECURITY_KEY_EMAIL";
        email?: string | undefined;
    } | {
        type: "SIGNIN_PASSWORD";
        email?: string | undefined;
        /**
         * @internal
         * This is a private API.
         */
        password?: string | undefined;
    } | {
        type: "PASSWORDLESS_EMAIL";
        email?: string | undefined;
        options?: import('./types').PasswordlessOptions | undefined;
    } | {
        type: "PASSWORDLESS_SMS";
        phoneNumber?: string | undefined;
        options?: import('./types').PasswordlessOptions | undefined;
    } | {
        type: "PASSWORDLESS_SMS_OTP";
        phoneNumber?: string | undefined;
        otp?: string | undefined;
    } | {
        type: "SIGNUP_EMAIL_PASSWORD";
        email?: string | undefined;
        password?: string | undefined;
        options?: import('./types').SignUpOptions | undefined;
    } | {
        type: "SIGNUP_SECURITY_KEY";
        email?: string | undefined;
        options?: import('./types').SignUpSecurityKeyOptions | undefined;
    } | {
        type: "SIGNOUT";
        all?: boolean | undefined;
    } | {
        type: "SIGNIN_MFA_TOTP";
        ticket?: string | undefined;
        otp?: string | undefined;
    } | {
        type: "SIGNED_IN";
    } | {
        type: "SIGNED_OUT";
    } | {
        type: "TOKEN_CHANGED";
    } | {
        type: "AWAIT_EMAIL_VERIFICATION";
    }, {
        value: any;
        context: AuthContext;
    }, import('xstate').BaseActionObject, {
        signInPassword: {
            data: import('./types').SignInResponse;
        };
        passwordlessSms: {
            data: import('./types').DeanonymizeResponse | import('./types').PasswordlessSmsResponse;
        };
        passwordlessSmsOtp: {
            data: import('./types').NhostSessionResponse;
        };
        passwordlessEmail: {
            data: import('./types').DeanonymizeResponse | import('./types').PasswordlessEmailResponse;
        };
        signInAnonymous: {
            data: import('./types').NhostSessionResponse;
        };
        signInPAT: {
            data: import('./types').NhostSessionResponse;
        };
        signInMfaTotp: {
            data: import('./types').NhostSessionResponse;
        };
        signInSecurityKeyEmail: {
            data: import('./types').SignInResponse;
        };
        refreshToken: {
            data: import('./types').NhostSessionResponse;
        };
        signout: {
            data: import('./types').SignOutResponse;
        };
        signUpEmailPassword: {
            data: import('./types').NhostSessionResponse;
        };
        signUpSecurityKey: {
            data: import('./types').NhostSessionResponse;
        };
        importRefreshToken: {
            data: import('./types').NhostSessionResponse;
        };
    }, import('xstate').ResolveTypegenMeta<import('./machines/authentication/machine.typegen').Typegen0, {
        type: "SESSION_UPDATE";
        data: {
            session: NhostSession;
        };
    } | {
        type: "TRY_TOKEN";
        token: string;
    } | {
        type: "SIGNIN_ANONYMOUS";
    } | {
        type: "SIGNIN_PAT";
        pat: string;
    } | {
        type: "SIGNIN_SECURITY_KEY_EMAIL";
        email?: string | undefined;
    } | {
        type: "SIGNIN_PASSWORD";
        email?: string | undefined;
        /**
         * @internal
         * This is a private API.
         */
        password?: string | undefined;
    } | {
        type: "PASSWORDLESS_EMAIL";
        email?: string | undefined;
        options?: import('./types').PasswordlessOptions | undefined;
    } | {
        type: "PASSWORDLESS_SMS";
        phoneNumber?: string | undefined;
        options?: import('./types').PasswordlessOptions | undefined;
    } | {
        type: "PASSWORDLESS_SMS_OTP";
        phoneNumber?: string | undefined;
        otp?: string | undefined;
    } | {
        type: "SIGNUP_EMAIL_PASSWORD";
        email?: string | undefined;
        password?: string | undefined;
        options?: import('./types').SignUpOptions | undefined;
    } | {
        type: "SIGNUP_SECURITY_KEY";
        email?: string | undefined;
        options?: import('./types').SignUpSecurityKeyOptions | undefined;
    } | {
        type: "SIGNOUT";
        all?: boolean | undefined;
    } | {
        type: "SIGNIN_MFA_TOTP";
        ticket?: string | undefined;
        otp?: string | undefined;
    } | {
        type: "SIGNED_IN";
    } | {
        type: "SIGNED_OUT";
    } | {
        type: "TOKEN_CHANGED";
    } | {
        type: "AWAIT_EMAIL_VERIFICATION";
    }, import('xstate').BaseActionObject, {
        signInPassword: {
            data: import('./types').SignInResponse;
        };
        passwordlessSms: {
            data: import('./types').DeanonymizeResponse | import('./types').PasswordlessSmsResponse;
        };
        passwordlessSmsOtp: {
            data: import('./types').NhostSessionResponse;
        };
        passwordlessEmail: {
            data: import('./types').DeanonymizeResponse | import('./types').PasswordlessEmailResponse;
        };
        signInAnonymous: {
            data: import('./types').NhostSessionResponse;
        };
        signInPAT: {
            data: import('./types').NhostSessionResponse;
        };
        signInMfaTotp: {
            data: import('./types').NhostSessionResponse;
        };
        signInSecurityKeyEmail: {
            data: import('./types').SignInResponse;
        };
        refreshToken: {
            data: import('./types').NhostSessionResponse;
        };
        signout: {
            data: import('./types').SignOutResponse;
        };
        signUpEmailPassword: {
            data: import('./types').NhostSessionResponse;
        };
        signUpSecurityKey: {
            data: import('./types').NhostSessionResponse;
        };
        importRefreshToken: {
            data: import('./types').NhostSessionResponse;
        };
    }>>;
    get interpreter(): AuthInterpreter | undefined;
    get started(): boolean;
    subscribe(fn: (client: AuthClient) => () => void): () => void;
}
/** @deprecated Not in use anymore. Use `clientStorageType: 'cookie'` instead */
export declare class AuthCookieClient extends AuthClient {
    constructor({ ...options }: Omit<NhostClientOptions, 'clientStorageGetter' | 'clientStorageSetter' | 'clientStorage' | 'clientStorageType'>);
}
/** @deprecated Alias for {@link AuthCookieClient} */
export declare const AuthClientSSR: typeof AuthCookieClient;
//# sourceMappingURL=internal-client.d.ts.map