{"version":3,"file":"index.esm.js","sources":["../src/constants.ts","../src/errors.ts","../src/machines/authentication/context.ts","../../../node_modules/.pnpm/@simplewebauthn+browser@9.0.1/node_modules/@simplewebauthn/browser/dist/bundle/index.js","../src/local-storage.ts","../src/utils/client-helpers.ts","../src/utils/environment.ts","../src/utils/fetch.ts","../src/utils/url.ts","../src/utils/validators.ts","../src/machines/authentication/machine.ts","../src/machines/change-email.ts","../src/machines/change-password.ts","../src/machines/enable-mfa.ts","../src/machines/reset-password.ts","../src/machines/send-verification-email.ts","../src/internal-client.ts","../src/promises/addSecurityKey.ts","../src/promises/changeEmail.ts","../src/promises/changePassword.ts","../src/promises/mfa.ts","../src/promises/resetPassword.ts","../src/promises/sendVerificationEmail.ts","../src/promises/signInAnonymous.ts","../src/promises/signInEmailPassword.ts","../src/promises/signInEmailPasswordless.ts","../src/promises/signInEmailSecurityKey.ts","../src/promises/elevateEmailSecurityKey.ts","../src/promises/signInMfaTotp.ts","../src/promises/signInPAT.ts","../src/promises/signInSmsPasswordless.ts","../src/promises/signInSmsPasswordlessOtp.ts","../src/promises/signOut.ts","../src/promises/signUpEmailPassword.ts","../src/promises/signUpEmailSecurityKey.ts","../src/promises/createPAT.ts","../src/hasura-auth-client.ts"],"sourcesContent":["export const NHOST_REFRESH_TOKEN_KEY = 'nhostRefreshToken'\nexport const NHOST_REFRESH_TOKEN_ID_KEY = 'nhostRefreshTokenId'\nexport const NHOST_JWT_EXPIRES_AT_KEY = 'nhostRefreshTokenExpiresAt'\n\nexport const MIN_PASSWORD_LENGTH = 3\n\n/**\n * Minimum time in seconds between now and the JWT expiration time before the JWT is refreshed\n * For instance, if set to 60, the client will refresh the JWT one minute before it expires\n */\nexport const TOKEN_REFRESH_MARGIN_SECONDS = 60\n\nexport const REFRESH_TOKEN_MAX_ATTEMPTS = 5\n","import { AuthErrorPayload } from './types'\n\nexport const NETWORK_ERROR_CODE = 0\nexport const OTHER_ERROR_CODE = 1\nexport const VALIDATION_ERROR_CODE = 10\nexport const STATE_ERROR_CODE = 20\n\n/**\n * @internal\n * Adds a standard error payload to any JS Error, or convert a standard error payload into a JS Error.\n * Allows xstate to use `throw` instead of `Promise.reject` to propagate errors.\n * See https://github.com/statelyai/xstate/issues/3037\n */\nexport class CodifiedError extends Error {\n  error: AuthErrorPayload\n  constructor(original: Error | AuthErrorPayload) {\n    super(original.message)\n\n    if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor)\n\n    if (original instanceof Error) {\n      this.name = original.name\n      this.error = {\n        error: original.name,\n        status: OTHER_ERROR_CODE,\n        message: original.message\n      }\n    } else {\n      this.name = original.error\n      this.error = original\n    }\n  }\n}\n\nexport type ValidationAuthErrorPayload = AuthErrorPayload & { status: typeof VALIDATION_ERROR_CODE }\n\n// TODO share with hasura-auth\nexport const INVALID_EMAIL_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-email',\n  message: 'Email is incorrectly formatted'\n}\n\nexport const INVALID_MFA_TYPE_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-mfa-type',\n  message: 'MFA type is invalid'\n}\n\nexport const INVALID_MFA_CODE_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-mfa-code',\n  message: 'MFA code is invalid'\n}\n\nexport const INVALID_PASSWORD_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-password',\n  message: 'Password is incorrectly formatted'\n}\n\nexport const INVALID_PHONE_NUMBER_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-phone-number',\n  message: 'Phone number is incorrectly formatted'\n}\n\nexport const INVALID_MFA_TICKET_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-mfa-ticket',\n  message: 'MFA ticket is invalid'\n}\n\nexport const NO_MFA_TICKET_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'no-mfa-ticket',\n  message: 'No MFA ticket has been provided'\n}\n\nexport const NO_REFRESH_TOKEN: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'no-refresh-token',\n  message: 'No refresh token has been provided'\n}\n\nexport const TOKEN_REFRESHER_RUNNING_ERROR: AuthErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'refresher-already-running',\n  message:\n    'The token refresher is already running. You must wait until is has finished before submitting a new token.'\n}\n\nexport const USER_ALREADY_SIGNED_IN: AuthErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'already-signed-in',\n  message: 'User is already signed in'\n}\n\nexport const USER_UNAUTHENTICATED: AuthErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'unauthenticated-user',\n  message: 'User is not authenticated'\n}\n\nexport const USER_NOT_ANONYMOUS: AuthErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'user-not-anonymous',\n  message: 'User is not anonymous'\n}\n\nexport const EMAIL_NEEDS_VERIFICATION: AuthErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'unverified-user',\n  message: 'Email needs verification'\n}\n\nexport const INVALID_REFRESH_TOKEN: AuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-refresh-token',\n  message: 'Invalid or expired refresh token'\n}\n\nexport const INVALID_SIGN_IN_METHOD: AuthErrorPayload = {\n  status: OTHER_ERROR_CODE,\n  error: 'invalid-sign-in-method',\n  message: 'Invalid sign-in method'\n}\n","import { AuthErrorPayload, User } from '../../types'\n\nexport type StateErrorTypes = 'registration' | 'authentication' | 'signout'\n\nexport type AuthContext = {\n  user: User | null\n  mfa: {\n    ticket: string\n  } | null\n  accessToken: {\n    value: string | null\n    expiresAt: Date | null\n    expiresInSeconds: number | null\n  }\n  refreshTimer: {\n    startedAt: Date | null\n    attempts: number\n    lastAttempt: Date | null\n  }\n  refreshToken: {\n    value: string | null\n    isPAT?: boolean\n  }\n  /** Number of times the user tried to get an access token from a refresh token but got a network error */\n  importTokenAttempts: number\n  errors: Partial<Record<StateErrorTypes, AuthErrorPayload>>\n}\n\nexport const INITIAL_MACHINE_CONTEXT: AuthContext = {\n  user: null,\n  mfa: null,\n  accessToken: {\n    value: null,\n    expiresAt: null,\n    expiresInSeconds: 15\n  },\n  refreshTimer: {\n    startedAt: null,\n    attempts: 0,\n    lastAttempt: null\n  },\n  refreshToken: {\n    value: null\n  },\n  importTokenAttempts: 0,\n  errors: {}\n}\n","/* [@simplewebauthn/browser@9.0.1] */\nfunction utf8StringToBuffer(value) {\n    return new TextEncoder().encode(value);\n}\n\nfunction bufferToBase64URLString(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let str = '';\n    for (const charCode of bytes) {\n        str += String.fromCharCode(charCode);\n    }\n    const base64String = btoa(str);\n    return base64String.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nfunction base64URLStringToBuffer(base64URLString) {\n    const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');\n    const padLength = (4 - (base64.length % 4)) % 4;\n    const padded = base64.padEnd(base64.length + padLength, '=');\n    const binary = atob(padded);\n    const buffer = new ArrayBuffer(binary.length);\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n}\n\nfunction browserSupportsWebAuthn() {\n    return (window?.PublicKeyCredential !== undefined &&\n        typeof window.PublicKeyCredential === 'function');\n}\n\nfunction toPublicKeyCredentialDescriptor(descriptor) {\n    const { id } = descriptor;\n    return {\n        ...descriptor,\n        id: base64URLStringToBuffer(id),\n        transports: descriptor.transports,\n    };\n}\n\nfunction isValidDomain(hostname) {\n    return (hostname === 'localhost' ||\n        /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n\nclass WebAuthnError extends Error {\n    constructor({ message, code, cause, name, }) {\n        super(message, { cause });\n        this.name = name ?? cause.name;\n        this.code = code;\n    }\n}\n\nfunction identifyRegistrationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            return new WebAuthnError({\n                message: 'Registration ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'ConstraintError') {\n        if (publicKey.authenticatorSelection?.requireResidentKey === true) {\n            return new WebAuthnError({\n                message: 'Discoverable credentials were required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT',\n                cause: error,\n            });\n        }\n        else if (publicKey.authenticatorSelection?.userVerification === 'required') {\n            return new WebAuthnError({\n                message: 'User verification was required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'InvalidStateError') {\n        return new WebAuthnError({\n            message: 'The authenticator was previously registered',\n            code: 'ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED',\n            cause: error,\n        });\n    }\n    else if (error.name === 'NotAllowedError') {\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'NotSupportedError') {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param) => param.type === 'public-key');\n        if (validPubKeyCredParams.length === 0) {\n            return new WebAuthnError({\n                message: 'No entry in pubKeyCredParams was of type \"public-key\"',\n                code: 'ERROR_MALFORMED_PUBKEYCREDPARAMS',\n                cause: error,\n            });\n        }\n        return new WebAuthnError({\n            message: 'No available authenticator supported any of the specified pubKeyCredParams algorithms',\n            code: 'ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rp.id !== effectiveDomain) {\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rp.id}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'TypeError') {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            return new WebAuthnError({\n                message: 'User ID was not between 1 and 64 characters',\n                code: 'ERROR_INVALID_USER_ID_LENGTH',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new credential',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n\nclass BaseWebAuthnAbortService {\n    createNewAbortSignal() {\n        if (this.controller) {\n            const abortError = new Error('Cancelling existing WebAuthn API call for new one');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n        }\n        const newController = new AbortController();\n        this.controller = newController;\n        return newController.signal;\n    }\n    cancelCeremony() {\n        if (this.controller) {\n            const abortError = new Error('Manually cancelling existing WebAuthn API call');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n            this.controller = undefined;\n        }\n    }\n}\nconst WebAuthnAbortService = new BaseWebAuthnAbortService();\n\nconst attachments = ['cross-platform', 'platform'];\nfunction toAuthenticatorAttachment(attachment) {\n    if (!attachment) {\n        return;\n    }\n    if (attachments.indexOf(attachment) < 0) {\n        return;\n    }\n    return attachment;\n}\n\nasync function startRegistration(creationOptionsJSON) {\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    const publicKey = {\n        ...creationOptionsJSON,\n        challenge: base64URLStringToBuffer(creationOptionsJSON.challenge),\n        user: {\n            ...creationOptionsJSON.user,\n            id: utf8StringToBuffer(creationOptionsJSON.user.id),\n        },\n        excludeCredentials: creationOptionsJSON.excludeCredentials?.map(toPublicKeyCredentialDescriptor),\n    };\n    const options = { publicKey };\n    options.signal = WebAuthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.create(options));\n    }\n    catch (err) {\n        throw identifyRegistrationError({ error: err, options });\n    }\n    if (!credential) {\n        throw new Error('Registration was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let transports = undefined;\n    if (typeof response.getTransports === 'function') {\n        transports = response.getTransports();\n    }\n    let responsePublicKeyAlgorithm = undefined;\n    if (typeof response.getPublicKeyAlgorithm === 'function') {\n        try {\n            responsePublicKeyAlgorithm = response.getPublicKeyAlgorithm();\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getPublicKeyAlgorithm()', error);\n        }\n    }\n    let responsePublicKey = undefined;\n    if (typeof response.getPublicKey === 'function') {\n        try {\n            const _publicKey = response.getPublicKey();\n            if (_publicKey !== null) {\n                responsePublicKey = bufferToBase64URLString(_publicKey);\n            }\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getPublicKey()', error);\n        }\n    }\n    let responseAuthenticatorData;\n    if (typeof response.getAuthenticatorData === 'function') {\n        try {\n            responseAuthenticatorData = bufferToBase64URLString(response.getAuthenticatorData());\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getAuthenticatorData()', error);\n        }\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            attestationObject: bufferToBase64URLString(response.attestationObject),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            transports,\n            publicKeyAlgorithm: responsePublicKeyAlgorithm,\n            publicKey: responsePublicKey,\n            authenticatorData: responseAuthenticatorData,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\nfunction warnOnBrokenImplementation(methodName, cause) {\n    console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${methodName}. You should report this error to them.\\n`, cause);\n}\n\nfunction bufferToUTF8String(value) {\n    return new TextDecoder('utf-8').decode(value);\n}\n\nfunction browserSupportsWebAuthnAutofill() {\n    const globalPublicKeyCredential = window\n        .PublicKeyCredential;\n    if (globalPublicKeyCredential.isConditionalMediationAvailable === undefined) {\n        return new Promise((resolve) => resolve(false));\n    }\n    return globalPublicKeyCredential.isConditionalMediationAvailable();\n}\n\nfunction identifyAuthenticationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            return new WebAuthnError({\n                message: 'Authentication ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'NotAllowedError') {\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rpId !== effectiveDomain) {\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rpId}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new assertion signature',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n\nasync function startAuthentication(requestOptionsJSON, useBrowserAutofill = false) {\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    let allowCredentials;\n    if (requestOptionsJSON.allowCredentials?.length !== 0) {\n        allowCredentials = requestOptionsJSON.allowCredentials?.map(toPublicKeyCredentialDescriptor);\n    }\n    const publicKey = {\n        ...requestOptionsJSON,\n        challenge: base64URLStringToBuffer(requestOptionsJSON.challenge),\n        allowCredentials,\n    };\n    const options = {};\n    if (useBrowserAutofill) {\n        if (!(await browserSupportsWebAuthnAutofill())) {\n            throw Error('Browser does not support WebAuthn autofill');\n        }\n        const eligibleInputs = document.querySelectorAll('input[autocomplete$=\\'webauthn\\']');\n        if (eligibleInputs.length < 1) {\n            throw Error('No <input> with \"webauthn\" as the only or last value in its `autocomplete` attribute was detected');\n        }\n        options.mediation = 'conditional';\n        publicKey.allowCredentials = [];\n    }\n    options.publicKey = publicKey;\n    options.signal = WebAuthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.get(options));\n    }\n    catch (err) {\n        throw identifyAuthenticationError({ error: err, options });\n    }\n    if (!credential) {\n        throw new Error('Authentication was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let userHandle = undefined;\n    if (response.userHandle) {\n        userHandle = bufferToUTF8String(response.userHandle);\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            authenticatorData: bufferToBase64URLString(response.authenticatorData),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            signature: bufferToBase64URLString(response.signature),\n            userHandle,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\n\nfunction platformAuthenticatorIsAvailable() {\n    if (!browserSupportsWebAuthn()) {\n        return new Promise((resolve) => resolve(false));\n    }\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\n\nexport { WebAuthnAbortService, WebAuthnError, base64URLStringToBuffer, browserSupportsWebAuthn, browserSupportsWebAuthnAutofill, bufferToBase64URLString, platformAuthenticatorIsAvailable, startAuthentication, startRegistration };\n","import Cookies from 'js-cookie'\n\nimport { ClientStorage, ClientStorageType, StorageGetter, StorageSetter } from './types'\n\nconst isBrowser = typeof window !== 'undefined'\n\nconst inMemoryLocalStorage: Map<string, string | null> = new Map()\n\nconst defaultClientStorageGetter: StorageGetter = (key) => {\n  if (isBrowser && typeof localStorage !== 'undefined') return localStorage.getItem(key)\n  else return inMemoryLocalStorage.get(key) ?? null\n}\n\nconst defaultClientStorageSetter: StorageSetter = (key, value) => {\n  if (isBrowser && typeof localStorage !== 'undefined') {\n    if (value) {\n      localStorage.setItem(key, value)\n    } else {\n      localStorage.removeItem(key)\n    }\n  } else {\n    if (value) {\n      inMemoryLocalStorage.set(key, value)\n    } else if (inMemoryLocalStorage.has(key)) {\n      inMemoryLocalStorage.delete(key)\n    }\n  }\n}\n\nexport const localStorageGetter = (\n  clientStorageType: ClientStorageType,\n  clientStorage?: ClientStorage\n): StorageGetter => {\n  if (clientStorageType === 'localStorage' || clientStorageType === 'web') {\n    return defaultClientStorageGetter\n  }\n  if (clientStorageType === 'cookie') {\n    return (key) => {\n      if (isBrowser) {\n        return Cookies.get(key) ?? null\n      } else {\n        return null\n      }\n    }\n  }\n  if (!clientStorage) {\n    throw Error(\n      `clientStorageType is set to '${clientStorageType}' but no clientStorage has been given`\n    )\n  }\n  if (clientStorageType === 'react-native') {\n    return (key) => clientStorage.getItem?.(key)\n  }\n  if (clientStorageType === 'capacitor') {\n    return (key) => clientStorage.get?.({ key })\n  }\n  if (clientStorageType === 'expo-secure-storage') {\n    return (key) => clientStorage.getItemAsync?.(key)\n  }\n  if (clientStorageType === 'custom') {\n    if (clientStorage.getItem && clientStorage.removeItem) {\n      return clientStorage.getItem\n    }\n    if (clientStorage.getItemAsync) {\n      return clientStorage.getItemAsync\n    }\n    throw Error(\n      `clientStorageType is set to 'custom' but clientStorage is missing either \"getItem\" and \"removeItem\" properties or \"getItemAsync\" property`\n    )\n  }\n  throw Error(`Unknown storage type: ${clientStorageType}`)\n}\n\nexport const localStorageSetter = (\n  clientStorageType: ClientStorageType,\n  clientStorage?: ClientStorage\n): StorageSetter => {\n  if (clientStorageType === 'localStorage' || clientStorageType === 'web') {\n    return defaultClientStorageSetter\n  }\n  if (clientStorageType === 'cookie') {\n    return (key, value) => {\n      if (isBrowser) {\n        if (value) {\n          // TODO: Set expires based on the actual refresh token expire time\n          // For now, we're using 30 days so the cookie is not removed when the browser is closed because if `expiers` is omitted, the cookie becomes a session cookie.\n          Cookies.set(key, value, { expires: 30, sameSite: 'lax', httpOnly: false })\n        } else {\n          Cookies.remove(key)\n        }\n      }\n    }\n  }\n  if (!clientStorage) {\n    throw Error(\n      `clientStorageType is set to '${clientStorageType}' but no clienStorage has been given`\n    )\n  }\n  if (clientStorageType === 'react-native') {\n    return (key, value) =>\n      value ? clientStorage.setItem?.(key, value) : clientStorage.removeItem?.(key)\n  }\n  if (clientStorageType === 'capacitor') {\n    return (key, value) =>\n      value ? clientStorage.set?.({ key, value }) : clientStorage.remove?.({ key })\n  }\n  if (clientStorageType === 'expo-secure-storage') {\n    return async (key, value) =>\n      value ? clientStorage.setItemAsync?.(key, value) : clientStorage.deleteItemAsync?.(key)\n  }\n  if (clientStorageType === 'custom') {\n    if (!clientStorage.removeItem) {\n      throw Error(\n        `clientStorageType is set to 'custom' but clientStorage is missing a removeItem property`\n      )\n    }\n    if (clientStorage.setItem) {\n      return (key, value) =>\n        value ? clientStorage.setItem?.(key, value) : clientStorage.removeItem?.(key)\n    }\n    if (clientStorage.setItemAsync) {\n      return async (key, value) =>\n        value ? clientStorage.setItemAsync?.(key, value) : clientStorage.removeItem?.(key)\n    }\n    throw Error(\n      `clientStorageType is set to 'custom' but clientStorage is missing setItem or setItemAsync property`\n    )\n  }\n  throw Error(`Unknown storage type: ${clientStorageType}`)\n}\n","import { AuthContext } from '../machines'\nimport { SessionActionHandlerResult } from '../promises'\nimport { NhostSession, SignUpResponse } from '../types'\n\nexport const getSession = (context?: AuthContext): NhostSession | null => {\n  if (!context || !context.accessToken.value || !context.accessToken.expiresAt || !context.user) {\n    return null\n  }\n  return {\n    accessToken: context.accessToken.value,\n    accessTokenExpiresIn: (context.accessToken.expiresAt.getTime() - Date.now()) / 1000,\n    refreshToken: context.refreshToken.value,\n    user: context.user\n  }\n}\n\nexport const getAuthenticationResult = ({\n  accessToken,\n  refreshToken,\n  isError,\n  user,\n  error\n}: SessionActionHandlerResult): SignUpResponse => {\n  if (isError) {\n    return {\n      session: null,\n      error\n    }\n  }\n  if (user && accessToken) {\n    return {\n      // TODO either return the refresh token or remove it from the session type\n      session: { accessToken, accessTokenExpiresIn: 0, refreshToken: refreshToken, user },\n      error: null\n    }\n  }\n  return { session: null, error: null }\n}\n","export const isBrowser = () =>\n  typeof window !== 'undefined' && typeof window.location !== 'undefined'\n","import fetchPonyfill from 'fetch-ponyfill'\nimport { NETWORK_ERROR_CODE } from '../errors'\nimport { NullableErrorResponse } from '../types'\n\ndeclare const EdgeRuntime: any\n\ninterface FetcResponse<T> extends NullableErrorResponse {\n  data: T\n}\n\nlet fetch = globalThis.fetch\n\nif (typeof EdgeRuntime !== 'string') {\n  fetch = fetchPonyfill().fetch\n}\n\nconst fetchWrapper = async <T>(\n  url: string,\n  method: 'GET' | 'POST',\n  { token, body }: { token?: string | null; body?: any } = {}\n): Promise<FetcResponse<T>> => {\n  const headers: HeadersInit = {\n    'Content-Type': 'application/json',\n    Accept: '*/*'\n  }\n  if (token) {\n    headers['Authorization'] = `Bearer ${token}`\n  }\n  const options: RequestInit = {\n    method,\n    headers\n  }\n  if (body) {\n    options.body = JSON.stringify(body)\n  }\n  try {\n    const result = await fetch(url, options)\n    if (!result.ok) {\n      const error = await result.json()\n      return Promise.reject<FetcResponse<T>>({ error })\n    }\n    try {\n      const data = await result.json()\n      return { data, error: null }\n    } catch {\n      console.warn(`Unexpected response: can't parse the response of the server at ${url}`)\n      return { data: 'OK' as any, error: null }\n    }\n  } catch (e) {\n    const error = {\n      message: 'Network Error',\n      status: NETWORK_ERROR_CODE,\n      error: 'network'\n    }\n    return Promise.reject<FetcResponse<T>>({ error })\n  }\n}\n\nexport const postFetch = async <T>(\n  url: string,\n  body: any,\n  token?: string | null\n): Promise<FetcResponse<T>> => fetchWrapper<T>(url, 'POST', { token, body })\n\nexport const getFetch = <T>(url: string, token?: string | null): Promise<FetcResponse<T>> =>\n  fetchWrapper<T>(url, 'GET', { token })\n","import { RedirectOption } from '../types'\n\nexport const encodeQueryParameters = (baseUrl: string, parameters?: Record<string, unknown>) => {\n  const encodedParameters =\n    parameters &&\n    Object.entries(parameters)\n      .map(([key, value]) => {\n        const stringValue = Array.isArray(value)\n          ? value.join(',')\n          : typeof value === 'object'\n          ? JSON.stringify(value)\n          : (value as string)\n        return `${key}=${encodeURIComponent(stringValue)}`\n      })\n      .join('&')\n  if (encodedParameters) return `${baseUrl}?${encodedParameters}`\n  else return baseUrl\n}\n\n/**\n * Transform options that include a redirectTo property so the\n * redirect url is absolute, given a base clientUrl.\n * If no client url is given, any relative redirectUrl is removed while\n * the other options are sent as-is.\n * @param clientUrl base client url\n * @param options\n * @returns\n */\nexport const rewriteRedirectTo = <T extends RedirectOption>(\n  clientUrl?: string,\n  options?: T\n): (Omit<T, 'redirectTo'> & { redirectTo?: string }) | undefined => {\n  if (!options?.redirectTo) {\n    return options\n  }\n  const { redirectTo, ...otherOptions } = options\n  // * If the clientUrl is not defined, we can't rewrite the redirectTo\n  if (!clientUrl) {\n    // * If redirectTo is a relative path, we therefore pull it out of the options\n    if (redirectTo.startsWith('/')) {\n      return otherOptions\n    } else {\n      return options\n    }\n  }\n  const baseClientUrl = new URL(clientUrl)\n  const clientParams = Object.fromEntries(new URLSearchParams(baseClientUrl.search))\n  const url = new URL(redirectTo.startsWith('/') ? baseClientUrl.origin + redirectTo : redirectTo)\n  const additionalParams = new URLSearchParams(url.search)\n  let combinedParams = Object.fromEntries(additionalParams)\n\n  if (redirectTo.startsWith('/')) {\n    combinedParams = { ...clientParams, ...combinedParams }\n  }\n  let pathName = baseClientUrl.pathname\n  if (url.pathname.length > 1) {\n    pathName += url.pathname.slice(1)\n  }\n  return {\n    ...otherOptions,\n    redirectTo: encodeQueryParameters(url.origin + pathName, combinedParams)\n  }\n}\n\nexport function getParameterByName(name: string, url?: string) {\n  if (!url) {\n    if (typeof window === 'undefined') {\n      return\n    }\n    url = window.location?.href || ''\n  }\n  // eslint-disable-next-line no-useless-escape\n  name = name.replace(/[\\[\\]]/g, '\\\\$&')\n  const regex = new RegExp('[?&#]' + name + '(=([^&#]*)|&|#|$)'),\n    results = regex.exec(url)\n  if (!results) return null\n  if (!results[2]) return ''\n  return decodeURIComponent(results[2].replace(/\\+/g, ' '))\n}\n\nexport function removeParameterFromWindow(name: string) {\n  if (typeof window === 'undefined') {\n    return\n  }\n  const location = window?.location\n  if (!location) {\n    return\n  }\n  if (location) {\n    const search = new URLSearchParams(location.search)\n    const hash = new URLSearchParams(location.hash?.slice(1))\n    search.delete(name)\n    hash.delete(name)\n    let url = window.location.pathname\n    if (Array.from(search).length) url += `?${search.toString()}`\n    if (Array.from(hash).length) url += `#${hash.toString()}`\n    window.history.pushState({}, '', url)\n  }\n}\n","import { MIN_PASSWORD_LENGTH } from '../constants'\n\nexport const isValidEmail = (email?: string | null) =>\n  !!email &&\n  typeof email === 'string' &&\n  !!String(email)\n    .toLowerCase()\n    .match(\n      /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/\n    )\n\nexport const isValidPassword = (password?: string | null) =>\n  !!password && typeof password === 'string' && password.length >= MIN_PASSWORD_LENGTH\n\n// TODO improve validation\nexport const isValidPhoneNumber = (phoneNumber?: string | null) =>\n  !!phoneNumber && typeof phoneNumber === 'string'\n\nexport const isValidTicket = (ticket?: string | null) =>\n  ticket &&\n  typeof ticket === 'string' &&\n  ticket.match(/^mfaTotp:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i)\n","import { startAuthentication, startRegistration } from '@simplewebauthn/browser'\nimport type {\n  AuthenticationCredentialJSON,\n  PublicKeyCredentialCreationOptionsJSON,\n  PublicKeyCredentialRequestOptionsJSON,\n  RegistrationCredentialJSON\n} from '@simplewebauthn/typescript-types'\nimport { InterpreterFrom, assign, createMachine, send } from 'xstate'\nimport {\n  NHOST_JWT_EXPIRES_AT_KEY,\n  NHOST_REFRESH_TOKEN_ID_KEY,\n  NHOST_REFRESH_TOKEN_KEY,\n  REFRESH_TOKEN_MAX_ATTEMPTS,\n  TOKEN_REFRESH_MARGIN_SECONDS\n} from '../../constants'\nimport {\n  CodifiedError,\n  INVALID_EMAIL_ERROR,\n  INVALID_MFA_TICKET_ERROR,\n  INVALID_PASSWORD_ERROR,\n  INVALID_PHONE_NUMBER_ERROR,\n  NETWORK_ERROR_CODE,\n  NO_MFA_TICKET_ERROR,\n  VALIDATION_ERROR_CODE\n} from '../../errors'\nimport { localStorageGetter, localStorageSetter } from '../../local-storage'\nimport {\n  AuthErrorPayload,\n  AuthOptions,\n  DeanonymizeResponse,\n  NhostSession,\n  NhostSessionResponse,\n  PasswordlessEmailResponse,\n  PasswordlessSmsOtpResponse,\n  PasswordlessSmsResponse,\n  RefreshSessionResponse,\n  SignInAnonymousResponse,\n  SignInMfaTotpResponse,\n  SignInPATResponse,\n  SignInResponse,\n  SignOutResponse,\n  SignUpResponse\n} from '../../types'\nimport {\n  getParameterByName,\n  isValidEmail,\n  isValidPassword,\n  isValidPhoneNumber,\n  isValidTicket,\n  postFetch,\n  removeParameterFromWindow,\n  rewriteRedirectTo\n} from '../../utils'\nimport { AuthContext, INITIAL_MACHINE_CONTEXT } from './context'\nimport { AuthEvents } from './events'\n\nexport interface AuthMachineOptions extends AuthOptions {\n  backendUrl: string\n  clientUrl: string\n}\n\nexport type AuthMachine = ReturnType<typeof createAuthMachine>\nexport type AuthInterpreter = InterpreterFrom<AuthMachine>\n\ntype AuthServices = {\n  signInPassword: { data: SignInResponse }\n  passwordlessSms: { data: PasswordlessSmsResponse | DeanonymizeResponse }\n  passwordlessSmsOtp: { data: PasswordlessSmsOtpResponse }\n  passwordlessEmail: { data: PasswordlessEmailResponse | DeanonymizeResponse }\n  signInAnonymous: { data: SignInAnonymousResponse }\n  signInPAT: { data: SignInPATResponse }\n  signInMfaTotp: { data: SignInMfaTotpResponse }\n  signInSecurityKeyEmail: { data: SignInResponse }\n  refreshToken: { data: NhostSessionResponse }\n  signout: { data: SignOutResponse }\n  signUpEmailPassword: { data: SignUpResponse }\n  signUpSecurityKey: { data: SignUpResponse }\n  importRefreshToken: { data: NhostSessionResponse }\n}\n\nexport const createAuthMachine = ({\n  backendUrl,\n  clientUrl,\n  clientStorageType = 'web',\n  clientStorage,\n  refreshIntervalTime,\n  autoRefreshToken = true,\n  autoSignIn = true\n}: AuthMachineOptions) => {\n  const storageGetter = localStorageGetter(clientStorageType, clientStorage)\n  const storageSetter = localStorageSetter(clientStorageType, clientStorage)\n  const postRequest = async <T = any, D = any>(\n    url: string,\n    data?: D,\n    token?: string | null\n  ): Promise<T> => {\n    const result = await postFetch<T>(`${backendUrl}${url}`, data, token)\n\n    return result.data\n  }\n  return createMachine(\n    {\n      schema: {\n        context: {} as AuthContext,\n        events: {} as AuthEvents,\n        services: {} as AuthServices\n      },\n      tsTypes: {} as import('./machine.typegen').Typegen0,\n      context: INITIAL_MACHINE_CONTEXT,\n      predictableActionArguments: true,\n      id: 'nhost',\n      type: 'parallel',\n      states: {\n        authentication: {\n          initial: 'starting',\n          on: {\n            SESSION_UPDATE: [\n              {\n                cond: 'hasSession',\n                actions: ['saveSession', 'resetTimer', 'reportTokenChanged'],\n                target: '.signedIn'\n              }\n            ]\n          },\n          states: {\n            starting: {\n              tags: ['loading'],\n              always: { cond: 'isSignedIn', target: 'signedIn' },\n              invoke: {\n                id: 'importRefreshToken',\n                src: 'importRefreshToken',\n                onDone: [\n                  {\n                    cond: 'hasSession',\n                    actions: ['saveSession', 'reportTokenChanged'],\n                    target: 'signedIn'\n                  },\n                  {\n                    target: 'signedOut'\n                  }\n                ],\n                onError: [\n                  {\n                    cond: 'shouldRetryImportToken',\n                    actions: 'incrementTokenImportAttempts',\n                    target: 'retryTokenImport'\n                  },\n                  { actions: ['saveAuthenticationError'], target: 'signedOut' }\n                ]\n              }\n            },\n            retryTokenImport: {\n              tags: ['loading'],\n              after: {\n                RETRY_IMPORT_TOKEN_DELAY: 'starting'\n              }\n            },\n            signedOut: {\n              initial: 'noErrors',\n              entry: 'reportSignedOut',\n              states: {\n                noErrors: {},\n                success: {},\n                needsSmsOtp: {},\n                needsMfa: {},\n                failed: {},\n                signingOut: {\n                  entry: ['clearContextExceptRefreshToken'],\n                  exit: ['destroyRefreshToken', 'reportTokenChanged'],\n                  invoke: {\n                    src: 'signout',\n                    id: 'signingOut',\n                    onDone: {\n                      target: 'success'\n                    },\n                    onError: {\n                      target: 'failed',\n                      actions: ['saveAuthenticationError']\n                    }\n                  }\n                }\n              },\n              on: {\n                SIGNIN_PASSWORD: 'authenticating.password',\n                SIGNIN_ANONYMOUS: 'authenticating.anonymous',\n                SIGNIN_SECURITY_KEY_EMAIL: 'authenticating.securityKeyEmail',\n                SIGNIN_MFA_TOTP: 'authenticating.mfa.totp',\n                SIGNIN_PAT: 'authenticating.pat'\n              }\n            },\n            authenticating: {\n              entry: 'resetErrors',\n              states: {\n                password: {\n                  invoke: {\n                    src: 'signInPassword',\n                    id: 'authenticateUserWithPassword',\n                    onDone: [\n                      {\n                        cond: 'hasMfaTicket',\n                        actions: ['saveMfaTicket'],\n                        target: '#nhost.authentication.signedOut.needsMfa'\n                      },\n                      {\n                        actions: ['saveSession', 'reportTokenChanged'],\n                        target: '#nhost.authentication.signedIn'\n                      }\n                    ],\n                    onError: [\n                      {\n                        cond: 'unverified',\n                        target: [\n                          '#nhost.authentication.signedOut',\n                          '#nhost.registration.incomplete.needsEmailVerification'\n                        ]\n                      },\n                      {\n                        actions: 'saveAuthenticationError',\n                        target: '#nhost.authentication.signedOut.failed'\n                      }\n                    ]\n                  }\n                },\n                pat: {\n                  invoke: {\n                    src: 'signInPAT',\n                    id: 'authenticateWithPAT',\n                    onDone: {\n                      actions: ['savePATSession', 'reportTokenChanged'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: {\n                      actions: 'saveAuthenticationError',\n                      target: '#nhost.authentication.signedOut.failed'\n                    }\n                  }\n                },\n                anonymous: {\n                  invoke: {\n                    src: 'signInAnonymous',\n                    id: 'authenticateAnonymously',\n                    onDone: {\n                      actions: ['saveSession', 'reportTokenChanged'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: {\n                      actions: 'saveAuthenticationError',\n                      target: '#nhost.authentication.signedOut.failed'\n                    }\n                  }\n                },\n                mfa: {\n                  states: {\n                    totp: {\n                      invoke: {\n                        src: 'signInMfaTotp',\n                        id: 'signInMfaTotp',\n                        onDone: {\n                          actions: ['saveSession', 'reportTokenChanged'],\n                          target: '#nhost.authentication.signedIn'\n                        },\n                        onError: {\n                          actions: ['saveAuthenticationError'],\n                          target: '#nhost.authentication.signedOut.failed'\n                        }\n                      }\n                    }\n                  }\n                },\n                securityKeyEmail: {\n                  invoke: {\n                    src: 'signInSecurityKeyEmail',\n                    id: 'authenticateUserWithSecurityKey',\n                    onDone: {\n                      actions: ['saveSession', 'reportTokenChanged'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: [\n                      {\n                        cond: 'unverified',\n                        target: [\n                          '#nhost.authentication.signedOut',\n                          '#nhost.registration.incomplete.needsEmailVerification'\n                        ]\n                      },\n                      {\n                        actions: 'saveAuthenticationError',\n                        target: '#nhost.authentication.signedOut.failed'\n                      }\n                    ]\n                  }\n                }\n              }\n            },\n            signedIn: {\n              type: 'parallel',\n              entry: ['reportSignedIn', 'cleanUrl', 'broadcastToken', 'resetErrors'],\n              on: {\n                SIGNOUT: 'signedOut.signingOut'\n              },\n              states: {\n                refreshTimer: {\n                  id: 'timer',\n                  initial: 'idle',\n                  states: {\n                    disabled: { type: 'final' },\n                    stopped: {\n                      always: {\n                        cond: 'noToken',\n                        target: 'idle'\n                      }\n                    },\n                    idle: {\n                      always: [\n                        { cond: 'isAutoRefreshDisabled', target: 'disabled' },\n                        { cond: 'isRefreshTokenPAT', target: 'disabled' },\n                        { cond: 'hasRefreshToken', target: 'running' }\n                      ]\n                    },\n                    running: {\n                      initial: 'pending',\n                      entry: 'resetTimer',\n                      states: {\n                        pending: {\n                          after: {\n                            '1000': {\n                              internal: false,\n                              target: 'pending'\n                            }\n                          },\n                          always: {\n                            cond: 'refreshTimerShouldRefresh',\n                            target: 'refreshing'\n                          }\n                        },\n                        refreshing: {\n                          invoke: {\n                            src: 'refreshToken',\n                            id: 'refreshToken',\n                            onDone: {\n                              actions: ['saveSession', 'resetTimer', 'reportTokenChanged'],\n                              target: 'pending'\n                            },\n                            onError: [{ actions: 'saveRefreshAttempt', target: 'pending' }]\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        },\n        token: {\n          initial: 'idle',\n          states: {\n            idle: {\n              on: {\n                TRY_TOKEN: 'running'\n              },\n              initial: 'noErrors',\n              states: { noErrors: {}, error: {} }\n            },\n            running: {\n              invoke: {\n                src: 'refreshToken',\n                id: 'authenticateWithToken',\n                onDone: {\n                  actions: ['saveSession', 'reportTokenChanged'],\n                  target: ['#nhost.authentication.signedIn', 'idle.noErrors']\n                },\n                onError: [\n                  { cond: 'isSignedIn', target: 'idle.error' },\n                  {\n                    actions: 'saveAuthenticationError',\n                    target: ['#nhost.authentication.signedOut.failed', 'idle.error']\n                  }\n                ]\n              }\n            }\n          }\n        },\n        registration: {\n          initial: 'incomplete',\n          on: {\n            SIGNED_IN: [{ cond: 'isAnonymous', target: '.incomplete' }, '.complete']\n          },\n          states: {\n            incomplete: {\n              on: {\n                SIGNUP_EMAIL_PASSWORD: 'emailPassword',\n                SIGNUP_SECURITY_KEY: 'securityKey',\n                PASSWORDLESS_EMAIL: 'passwordlessEmail',\n                PASSWORDLESS_SMS: 'passwordlessSms',\n                PASSWORDLESS_SMS_OTP: 'passwordlessSmsOtp'\n              },\n              initial: 'noErrors',\n              states: {\n                noErrors: {},\n                needsEmailVerification: {},\n                needsOtp: {},\n                failed: {}\n              }\n            },\n            emailPassword: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'signUpEmailPassword',\n                id: 'signUpEmailPassword',\n                onDone: [\n                  {\n                    cond: 'hasSession',\n                    actions: ['saveSession', 'reportTokenChanged'],\n                    target: '#nhost.authentication.signedIn'\n                  },\n                  {\n                    actions: 'clearContext',\n                    target: ['#nhost.authentication.signedOut', 'incomplete.needsEmailVerification']\n                  }\n                ],\n                onError: [\n                  {\n                    cond: 'unverified',\n                    target: 'incomplete.needsEmailVerification'\n                  },\n                  {\n                    actions: 'saveRegistrationError',\n                    target: 'incomplete.failed'\n                  }\n                ]\n              }\n            },\n            securityKey: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'signUpSecurityKey',\n                id: 'signUpSecurityKey',\n                onDone: [\n                  {\n                    cond: 'hasSession',\n                    actions: ['saveSession', 'reportTokenChanged'],\n                    target: '#nhost.authentication.signedIn'\n                  },\n                  {\n                    actions: 'clearContext',\n                    target: ['#nhost.authentication.signedOut', 'incomplete.needsEmailVerification']\n                  }\n                ],\n                onError: [\n                  {\n                    cond: 'unverified',\n                    target: 'incomplete.needsEmailVerification'\n                  },\n                  {\n                    actions: 'saveRegistrationError',\n                    target: 'incomplete.failed'\n                  }\n                ]\n              }\n            },\n            passwordlessEmail: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'passwordlessEmail',\n                id: 'passwordlessEmail',\n                onDone: {\n                  actions: 'clearContext',\n                  target: ['#nhost.authentication.signedOut', 'incomplete.needsEmailVerification']\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n            passwordlessSms: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'passwordlessSms',\n                id: 'passwordlessSms',\n                onDone: {\n                  actions: 'clearContext',\n                  target: ['#nhost.authentication.signedOut', 'incomplete.needsOtp']\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n            passwordlessSmsOtp: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'passwordlessSmsOtp',\n                id: 'passwordlessSmsOtp',\n                onDone: {\n                  actions: ['saveSession', 'reportTokenChanged'],\n                  target: '#nhost.authentication.signedIn'\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n\n            complete: {\n              on: {\n                SIGNED_OUT: 'incomplete'\n              }\n            }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        reportSignedIn: send('SIGNED_IN'),\n        reportSignedOut: send('SIGNED_OUT'),\n        reportTokenChanged: send('TOKEN_CHANGED'),\n        incrementTokenImportAttempts: assign({\n          importTokenAttempts: ({ importTokenAttempts }) => importTokenAttempts + 1\n        }),\n        clearContext: assign(() => {\n          storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n          storageSetter(NHOST_REFRESH_TOKEN_KEY, null)\n          storageSetter(NHOST_REFRESH_TOKEN_ID_KEY, null)\n          return {\n            ...INITIAL_MACHINE_CONTEXT\n          }\n        }),\n        clearContextExceptRefreshToken: assign(({ refreshToken: { value } }) => {\n          storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n          return {\n            ...INITIAL_MACHINE_CONTEXT,\n            refreshToken: { value }\n          }\n        }),\n\n        // * Save session in the context, and persist the refresh token and the jwt expiration outside of the machine\n        saveSession: assign({\n          user: (_, { data }) => data?.session?.user || null,\n          accessToken: (_, { data }) => {\n            if (data.session) {\n              const { accessTokenExpiresIn, accessToken } = data.session\n              const nextRefresh = new Date(Date.now() + accessTokenExpiresIn * 1_000)\n              storageSetter(NHOST_JWT_EXPIRES_AT_KEY, nextRefresh.toISOString())\n              return {\n                value: accessToken,\n                expiresAt: nextRefresh,\n                expiresInSeconds: accessTokenExpiresIn\n              }\n            }\n            storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n            return {\n              value: null,\n              expiresAt: null,\n              expiresInSeconds: null\n            }\n          },\n          refreshToken: (_, { data }) => {\n            const refreshToken = data.session?.refreshToken || null\n            const refreshTokenId = data.session?.refreshTokenId || null\n\n            if (refreshToken) {\n              storageSetter(NHOST_REFRESH_TOKEN_KEY, refreshToken)\n            }\n\n            if (refreshTokenId) {\n              storageSetter(NHOST_REFRESH_TOKEN_ID_KEY, refreshTokenId)\n            }\n\n            return { value: refreshToken }\n          }\n        }),\n\n        savePATSession: assign({\n          user: (_, { data }) => data?.session?.user || null,\n          accessToken: (_, { data }) => {\n            if (data.session) {\n              const { accessTokenExpiresIn, accessToken } = data.session\n              const nextRefresh = new Date(Date.now() + accessTokenExpiresIn * 1_000)\n              storageSetter(NHOST_JWT_EXPIRES_AT_KEY, nextRefresh.toISOString())\n              return {\n                value: accessToken,\n                expiresAt: nextRefresh,\n                expiresInSeconds: accessTokenExpiresIn\n              }\n            }\n            storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n            return {\n              value: null,\n              expiresAt: null,\n              expiresInSeconds: null\n            }\n          },\n          refreshToken: (_, { data }) => {\n            const refreshToken = data.session?.refreshToken || null\n            const refreshTokenId = data.session?.refreshTokenId || null\n\n            if (refreshToken) {\n              storageSetter(NHOST_REFRESH_TOKEN_KEY, refreshToken)\n            }\n\n            if (refreshTokenId) {\n              storageSetter(NHOST_REFRESH_TOKEN_ID_KEY, refreshTokenId)\n            }\n\n            return { value: refreshToken, isPAT: true }\n          }\n        }),\n\n        saveMfaTicket: assign({\n          mfa: (_, e) => e.data?.mfa\n        }),\n\n        resetTimer: assign({\n          refreshTimer: (_) => ({\n            startedAt: new Date(),\n            attempts: 0,\n            lastAttempt: null\n          })\n        }),\n\n        saveRefreshAttempt: assign({\n          refreshTimer: (ctx, e) => ({\n            startedAt: ctx.refreshTimer.startedAt,\n            attempts: ctx.refreshTimer.attempts + 1,\n            lastAttempt: new Date()\n          })\n        }),\n\n        // * Authentication errors\n        saveAuthenticationError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          errors: ({ errors }, { data: { error } }: any) => ({\n            ...errors,\n            authentication: error\n          })\n        }),\n        resetErrors: assign({\n          errors: (_) => ({}),\n          importTokenAttempts: (_) => 0\n        }),\n        saveRegistrationError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          errors: ({ errors }, { data: { error } }: any) => ({ ...errors, registration: error })\n        }),\n        destroyRefreshToken: assign({\n          refreshToken: (_) => {\n            storageSetter(NHOST_REFRESH_TOKEN_KEY, null)\n            storageSetter(NHOST_REFRESH_TOKEN_ID_KEY, null)\n            return { value: null }\n          }\n        }),\n\n        // * Clean the browser url when `autoSignIn` is activated\n        cleanUrl: () => {\n          if (autoSignIn && getParameterByName('refreshToken')) {\n            // * Remove the refresh token from the URL\n            removeParameterFromWindow('refreshToken')\n            removeParameterFromWindow('type')\n          }\n        },\n\n        // * Broadcast the token to other tabs when `autoSignIn` is activated\n        broadcastToken: (context) => {\n          if (autoSignIn) {\n            try {\n              const channel = new BroadcastChannel('nhost')\n              // ? broadcat session instead of token ?\n              channel.postMessage({\n                type: 'broadcast_token',\n                payload: {\n                  token: context.refreshToken.value\n                }\n              })\n            } catch (error) {\n              // * BroadcastChannel is not available e.g. react-native\n            }\n          }\n        }\n      },\n\n      guards: {\n        isAnonymous: (ctx, e) => !!ctx.user?.isAnonymous,\n        isSignedIn: (ctx) => !!ctx.user && !!ctx.accessToken.value,\n        noToken: (ctx) => !ctx.refreshToken.value,\n        isRefreshTokenPAT: (ctx) => !!ctx.refreshToken?.isPAT,\n        hasRefreshToken: (ctx) => !!ctx.refreshToken.value,\n        isAutoRefreshDisabled: () => !autoRefreshToken,\n        refreshTimerShouldRefresh: (ctx) => {\n          const { expiresAt } = ctx.accessToken\n\n          if (!expiresAt) {\n            return false\n          }\n\n          if (ctx.refreshTimer.lastAttempt) {\n            // * If the refresh timer reached the maximum number of attempts, we should not try again\n            if (ctx.refreshTimer.attempts > REFRESH_TOKEN_MAX_ATTEMPTS) {\n              return false\n            }\n            const elapsed = Date.now() - ctx.refreshTimer.lastAttempt.getTime()\n            // * Exponential backoff\n            return elapsed > Math.pow(2, ctx.refreshTimer.attempts - 1) * 5_000\n          }\n\n          // This happens when either the computer goes to sleep or when Chrome descides to suspend the tab\n          if (expiresAt.getTime() < Date.now()) {\n            return true\n          }\n\n          if (refreshIntervalTime) {\n            // * If a refreshIntervalTime has been passed on as an option, it will notify\n            // * the token should be refershed when this interval is overdue\n            const elapsed = Date.now() - ctx.refreshTimer.startedAt!.getTime()\n            if (elapsed > refreshIntervalTime * 1_000) {\n              return true\n            }\n          }\n          // * In any case, it's time to refresh when there's less than\n          // * TOKEN_REFRESH_MARGIN_SECONDS seconds before the JWT exprires\n          const accessTokenExpirationTime = ctx.accessToken.expiresInSeconds\n\n          if (!accessTokenExpirationTime) {\n            return false\n          }\n\n          const expiresInMilliseconds = expiresAt.getTime() - Date.now()\n\n          // If the token expires in less time than the margin, we should use\n          // a margin based on the token expiration time to avoid refreshing\n          // the token infinitely\n          const remainingMilliseconds =\n            expiresInMilliseconds -\n            1_000 * Math.min(TOKEN_REFRESH_MARGIN_SECONDS, accessTokenExpirationTime * 0.5)\n\n          return remainingMilliseconds <= 0\n        },\n        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n        /** Shoud retry to import the token on network error or any internal server error.\n         * Don't retry more than REFRESH_TOKEN_MAX_ATTEMPTS times.\n         */\n        shouldRetryImportToken: (ctx, e: any) =>\n          ctx.importTokenAttempts < REFRESH_TOKEN_MAX_ATTEMPTS &&\n          (e.data.error.status === NETWORK_ERROR_CODE || e.data.error.status >= 500),\n        // * Authentication errors\n        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n        unverified: (_, { data: { error } }: any) =>\n          error.status === 401 &&\n          // * legacy: don't use the message contents to determine if the email is unverified, but the error type (error.error)\n          (error.message === 'Email is not verified' || error.error === 'unverified-user'),\n\n        // * Event guards\n        hasSession: (_, e) => !!e.data?.session,\n        hasMfaTicket: (_, e) => !!e.data?.mfa\n      },\n\n      services: {\n        signInPassword: (_, { email, password }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject({ error: INVALID_EMAIL_ERROR })\n          }\n          if (!isValidPassword(password)) {\n            return Promise.reject({ error: INVALID_PASSWORD_ERROR })\n          }\n          return postRequest<SignInResponse>('/signin/email-password', {\n            email,\n            password\n          })\n        },\n        signInPAT: (_context, { pat }) => {\n          return postRequest<SignInPATResponse>('/signin/pat', {\n            personalAccessToken: pat\n          })\n        },\n        passwordlessSms: (context, { phoneNumber, options }) => {\n          if (!isValidPhoneNumber(phoneNumber)) {\n            return Promise.reject({ error: INVALID_PHONE_NUMBER_ERROR })\n          }\n          if (context.user?.isAnonymous) {\n            // TODO implement in hasura-auth\n            // * See https://github.com/nhost/hasura-auth/blob/9c6d0f4ded4fc8fd1b8031926c02796c74a7eada/src/routes/user/deanonymize.ts\n            console.warn(\n              'Deanonymisation from a phone number is not yet implemented in hasura-auth'\n            )\n            return postRequest(\n              '/user/deanonymize',\n              {\n                signInMethod: 'passwordless',\n                connection: 'sms',\n                phoneNumber,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              context.accessToken.value\n            )\n          } else {\n            return postRequest('/signin/passwordless/sms', {\n              phoneNumber,\n              options: rewriteRedirectTo(clientUrl, options)\n            })\n          }\n        },\n        passwordlessSmsOtp: (_, { phoneNumber, otp }) => {\n          if (!isValidPhoneNumber(phoneNumber)) {\n            return Promise.reject({ error: INVALID_PHONE_NUMBER_ERROR })\n          }\n          return postRequest('/signin/passwordless/sms/otp', {\n            phoneNumber,\n            otp\n          })\n        },\n        passwordlessEmail: (context, { email, options }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject({ error: INVALID_EMAIL_ERROR })\n          }\n          if (context.user?.isAnonymous) {\n            return postRequest(\n              '/user/deanonymize',\n              {\n                signInMethod: 'passwordless',\n                connection: 'email',\n                email,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              context.accessToken.value\n            )\n          } else {\n            return postRequest('/signin/passwordless/email', {\n              email,\n              options: rewriteRedirectTo(clientUrl, options)\n            })\n          }\n        },\n        signInAnonymous: (_) => postRequest('/signin/anonymous'),\n        signInMfaTotp: (context, data) => {\n          const ticket: string | undefined = data.ticket || context.mfa?.ticket\n          if (!ticket) {\n            return Promise.reject({ error: NO_MFA_TICKET_ERROR })\n          }\n          if (!isValidTicket(ticket)) {\n            return Promise.reject({ error: INVALID_MFA_TICKET_ERROR })\n          }\n\n          return postRequest('/signin/mfa/totp', {\n            ticket,\n            otp: data.otp\n          })\n        },\n        signInSecurityKeyEmail: async (_, { email }) => {\n          if (!isValidEmail(email)) {\n            throw new CodifiedError(INVALID_EMAIL_ERROR)\n          }\n          const options = await postRequest<PublicKeyCredentialRequestOptionsJSON>(\n            '/signin/webauthn',\n            { email }\n          )\n          let credential: AuthenticationCredentialJSON\n          try {\n            credential = await startAuthentication(options)\n          } catch (e) {\n            throw new CodifiedError(e as Error)\n          }\n          return postRequest<SignInResponse>('/signin/webauthn/verify', { email, credential })\n        },\n        refreshToken: async (ctx, event) => {\n          const refreshToken = event.type === 'TRY_TOKEN' ? event.token : ctx.refreshToken.value\n          const session = await postRequest<RefreshSessionResponse>('/token', {\n            refreshToken\n          })\n          return { session, error: null }\n        },\n        signout: async (ctx, e) => {\n          const signOutResponse = await postRequest('/signout', {\n            refreshToken: ctx.refreshToken.value,\n            all: !!e.all\n          })\n\n          try {\n            const channel = new BroadcastChannel('nhost')\n            // ? broadcast the signout event to other tabs to remove the accessToken\n            channel.postMessage({ type: 'signout' })\n          } catch (error) {\n            // * BroadcastChannel is not available e.g. react-native\n          }\n\n          return signOutResponse\n        },\n        signUpEmailPassword: async (context, { email, password, options }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject<SignUpResponse>({ error: INVALID_EMAIL_ERROR })\n          }\n          if (!isValidPassword(password)) {\n            return Promise.reject<SignUpResponse>({ error: INVALID_PASSWORD_ERROR })\n          }\n          if (context.user?.isAnonymous) {\n            return postRequest<SignUpResponse>(\n              '/user/deanonymize',\n              {\n                signInMethod: 'email-password',\n                email,\n                password,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              context.accessToken.value\n            )\n          } else {\n            return postRequest<SignUpResponse>('/signup/email-password', {\n              email,\n              password,\n              options: rewriteRedirectTo(clientUrl, options)\n            })\n          }\n        },\n        signUpSecurityKey: async (_, { email, options }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject<SignUpResponse>({ error: INVALID_EMAIL_ERROR })\n          }\n          // TODO anonymous users\n          const nickname = options?.nickname\n          /*\n           * The `/signup/webauthn` endpoint accepts any option from SignUpOptions,\n           * We therefore remove the nickname from the options object before sending it to the server,\n           * as options if of type `SignUpSecurityKeyOptions`, which extends `SignUpOptions` with the optional `nickname` property.\n           */\n          if (nickname) delete options.nickname\n          const webAuthnOptions = await postRequest<PublicKeyCredentialCreationOptionsJSON>(\n            '/signup/webauthn',\n            { email, options }\n          )\n          let credential: RegistrationCredentialJSON\n          try {\n            credential = await startRegistration(webAuthnOptions)\n          } catch (e) {\n            throw new CodifiedError(e as Error)\n          }\n          return postRequest<SignUpResponse>('/signup/webauthn/verify', {\n            credential,\n            options: {\n              redirectTo: options?.redirectTo,\n              nickname\n            }\n          })\n        },\n        importRefreshToken: async (ctx) => {\n          if (\n            ctx.user &&\n            ctx.refreshToken.value &&\n            ctx.accessToken.value &&\n            ctx.accessToken.expiresAt\n          ) {\n            // * Do not import refresh token if the session already exists (loaded through initial state)\n            // TODO this should eventually be handled upstream in the state machine\n            return {\n              session: {\n                accessToken: ctx.accessToken.value,\n                accessTokenExpiresIn: ctx.accessToken.expiresAt.getTime() - Date.now(),\n                refreshToken: ctx.refreshToken.value,\n                user: ctx.user\n              },\n              error: null\n            }\n          }\n          let error: AuthErrorPayload | null = null\n          if (autoSignIn) {\n            const urlToken = getParameterByName('refreshToken') || null\n            if (urlToken) {\n              try {\n                const session = await postRequest<NhostSession>('/token', {\n                  refreshToken: urlToken\n                })\n                return { session, error: null }\n              } catch (exception) {\n                error = (exception as { error: AuthErrorPayload }).error\n              }\n            } else {\n              const error = getParameterByName('error')\n              const errorDescription = getParameterByName('errorDescription')\n\n              if (error) {\n                if (errorDescription !== 'social user already exists') {\n                  return Promise.reject<NhostSessionResponse>({\n                    session: null,\n                    error: {\n                      status: VALIDATION_ERROR_CODE,\n                      error,\n                      message: errorDescription || error\n                    }\n                  })\n                }\n              }\n            }\n          }\n          const storageToken = await storageGetter(NHOST_REFRESH_TOKEN_KEY)\n          if (storageToken) {\n            try {\n              const session = await postRequest<NhostSession>('/token', {\n                refreshToken: storageToken\n              })\n              return { session, error: null }\n            } catch (exception) {\n              error = (exception as { error: AuthErrorPayload }).error\n            }\n          }\n          if (error) {\n            return Promise.reject<NhostSessionResponse>({ error, session: null })\n          }\n          return { error: null, session: null }\n        }\n      },\n      delays: {\n        RETRY_IMPORT_TOKEN_DELAY: ({ importTokenAttempts }) => {\n          // * Exponential backoff\n          return Math.pow(2, importTokenAttempts - 1) * 5_000\n        }\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\nimport { INVALID_EMAIL_ERROR } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, ChangeEmailOptions, ChangeEmailResponse } from '../types'\nimport { postFetch, rewriteRedirectTo } from '../utils'\nimport { isValidEmail } from '../utils/validators'\n\nexport type ChangeEmailContext = {\n  error: AuthErrorPayload | null\n}\n\nexport type ChangeEmailEvents =\n  | {\n      type: 'REQUEST'\n      email?: string\n      options?: ChangeEmailOptions\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: AuthErrorPayload | null }\n\nexport type ChangeEmailServices = {\n  request: { data: ChangeEmailResponse }\n}\n\nexport type ChangeEmailMachine = ReturnType<typeof createChangeEmailMachine>\n\nexport const createChangeEmailMachine = ({ backendUrl, clientUrl, interpreter }: AuthClient) => {\n  return createMachine(\n    {\n      schema: {\n        context: {} as ChangeEmailContext,\n        events: {} as ChangeEmailEvents,\n        services: {} as ChangeEmailServices\n      },\n      tsTypes: {} as import('./change-email.typegen').Typegen0,\n      predictableActionArguments: true,\n      id: 'changeEmail',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidEmail',\n                actions: 'saveInvalidEmailError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        // TODO change email in the main machine (context.user.email)\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidEmail: (_, { email }) => !isValidEmail(email)\n      },\n      services: {\n        requestChange: async (_, { email, options }) => {\n          const res = await postFetch(\n            `${backendUrl}/user/email/change`,\n            { newEmail: email, options: rewriteRedirectTo(clientUrl, options) },\n            interpreter?.getSnapshot().context.accessToken.value\n          )\n          return res.data\n        }\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\nimport { INVALID_PASSWORD_ERROR } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, ChangePasswordResponse } from '../types'\nimport { postFetch } from '../utils'\nimport { isValidPassword } from '../utils/validators'\n\nexport type ChangePasswordContext = {\n  error: AuthErrorPayload | null\n}\nexport type ChangePasswordEvents =\n  | {\n      type: 'REQUEST'\n      password?: string\n      ticket?: string\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: AuthErrorPayload | null }\n\nexport type ChangePasswordServices = {\n  requestChange: { data: ChangePasswordResponse }\n}\n\nexport type ChangePasswordMachine = ReturnType<typeof createChangePasswordMachine>\n\nexport const createChangePasswordMachine = ({ backendUrl, interpreter }: AuthClient) => {\n  return createMachine(\n    {\n      schema: {\n        context: {} as ChangePasswordContext,\n        events: {} as ChangePasswordEvents,\n        services: {} as ChangePasswordServices\n      },\n      tsTypes: {} as import('./change-password.typegen').Typegen0,\n      predictableActionArguments: true,\n      id: 'changePassword',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidPassword',\n                actions: 'saveInvalidPasswordError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidPasswordError: assign({ error: (_) => INVALID_PASSWORD_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidPassword: (_, { password }) => !isValidPassword(password)\n      },\n      services: {\n        requestChange: (_, { password, ticket }) =>\n          postFetch<ChangePasswordResponse>(\n            `${backendUrl}/user/password`,\n            { newPassword: password, ticket: ticket },\n            interpreter?.getSnapshot().context.accessToken.value\n          )\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\nimport { INVALID_MFA_CODE_ERROR, INVALID_MFA_TYPE_ERROR } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport { AuthErrorPayload } from '../types'\nimport { getFetch, postFetch } from '../utils'\n\nexport type EnableMfaContext = {\n  error: AuthErrorPayload | null\n  imageUrl: string | null\n  secret: string | null\n}\n\nexport type EnableMfaEvents =\n  | {\n      type: 'GENERATE'\n    }\n  | {\n      type: 'ACTIVATE'\n      code?: string\n      activeMfaType: 'totp'\n    }\n  | { type: 'GENERATED' }\n  | { type: 'GENERATED_ERROR'; error: AuthErrorPayload | null }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: AuthErrorPayload | null }\n\nexport type EnableMfadMachine = ReturnType<typeof createEnableMfaMachine>\n\nexport const createEnableMfaMachine = ({ backendUrl, interpreter }: AuthClient) => {\n  return createMachine(\n    {\n      schema: {\n        context: {} as EnableMfaContext,\n        events: {} as EnableMfaEvents\n      },\n      tsTypes: {} as import('./enable-mfa.typegen').Typegen0,\n      predictableActionArguments: true,\n      id: 'enableMfa',\n      initial: 'idle',\n      context: { error: null, imageUrl: null, secret: null },\n      states: {\n        idle: {\n          initial: 'initial',\n          on: {\n            GENERATE: 'generating'\n          },\n          states: {\n            initial: {},\n            error: {}\n          }\n        },\n        generating: {\n          invoke: {\n            src: 'generate',\n            id: 'generate',\n            onDone: { target: 'generated', actions: ['reportGeneratedSuccess', 'saveGeneration'] },\n            onError: { actions: ['saveError', 'reportGeneratedError'], target: 'idle.error' }\n          }\n        },\n        generated: {\n          initial: 'idle',\n          states: {\n            idle: {\n              initial: 'idle',\n              on: {\n                ACTIVATE: [\n                  {\n                    cond: 'invalidMfaType',\n                    actions: 'saveInvalidMfaTypeError',\n                    target: '.error'\n                  },\n                  {\n                    cond: 'invalidMfaCode',\n                    actions: 'saveInvalidMfaCodeError',\n                    target: '.error'\n                  },\n                  {\n                    target: 'activating'\n                  }\n                ]\n              },\n              states: { idle: {}, error: {} }\n            },\n            activating: {\n              invoke: {\n                src: 'activate',\n                id: 'activate',\n                onDone: { target: 'activated', actions: 'reportSuccess' },\n                onError: { actions: ['saveError', 'reportError'], target: 'idle.error' }\n              }\n            },\n            activated: { type: 'final' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidMfaTypeError: assign({ error: (_) => INVALID_MFA_TYPE_ERROR }),\n        saveInvalidMfaCodeError: assign({ error: (_) => INVALID_MFA_CODE_ERROR }),\n        saveError: assign({\n          error: (_, { data: { error } }: any) => error\n        }),\n        saveGeneration: assign({\n          imageUrl: (_, { data: { imageUrl } }: any) => imageUrl,\n          secret: (_, { data: { totpSecret } }: any) => totpSecret\n        }),\n        reportError: send((ctx, event) => {\n          console.log('REPORT', ctx, event)\n          return { type: 'ERROR', error: ctx.error }\n        }),\n        reportSuccess: send('SUCCESS'),\n        reportGeneratedSuccess: send('GENERATED'),\n        reportGeneratedError: send((ctx) => ({ type: 'GENERATED_ERROR', error: ctx.error }))\n      },\n      guards: {\n        invalidMfaCode: (_, { code }) => !code,\n        invalidMfaType: (_, { activeMfaType }) => !activeMfaType || activeMfaType !== 'totp'\n      },\n      services: {\n        generate: async (_) => {\n          const { data } = await getFetch(\n            `${backendUrl}/mfa/totp/generate`,\n            interpreter?.getSnapshot().context.accessToken.value\n          )\n          return data\n        },\n        activate: (_, { code, activeMfaType }) =>\n          postFetch(\n            `${backendUrl}/user/mfa`,\n            { code, activeMfaType },\n            interpreter?.getSnapshot().context.accessToken.value\n          )\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\nimport { INVALID_EMAIL_ERROR } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, ResetPasswordOptions, ResetPasswordResponse } from '../types'\nimport { postFetch, rewriteRedirectTo } from '../utils'\nimport { isValidEmail } from '../utils/validators'\n\nexport type ResetPasswordContext = {\n  error: AuthErrorPayload | null\n}\nexport type ResetPasswordEvents =\n  | {\n      type: 'REQUEST'\n      email?: string\n      options?: ResetPasswordOptions\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: AuthErrorPayload | null }\n\nexport type ResetPasswordServices = {\n  requestChange: { data: ResetPasswordResponse }\n}\n\nexport type ResetPasswordMachine = ReturnType<typeof createResetPasswordMachine>\n\nexport const createResetPasswordMachine = ({ backendUrl, clientUrl }: AuthClient) => {\n  return createMachine(\n    {\n      schema: {\n        context: {} as ResetPasswordContext,\n        events: {} as ResetPasswordEvents,\n        services: {} as ResetPasswordServices\n      },\n      tsTypes: {} as import('./reset-password.typegen').Typegen0,\n      predictableActionArguments: true,\n      id: 'changePassword',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidEmail',\n                actions: 'saveInvalidEmailError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidEmail: (_, { email }) => !isValidEmail(email)\n      },\n      services: {\n        requestChange: (_, { email, options }) =>\n          postFetch<ResetPasswordResponse>(`${backendUrl}/user/password/reset`, {\n            email,\n            options: rewriteRedirectTo(clientUrl, options)\n          })\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\nimport { INVALID_EMAIL_ERROR } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport {\n  AuthErrorPayload,\n  SendVerificationEmailOptions,\n  SendVerificationEmailResponse\n} from '../types'\nimport { postFetch, rewriteRedirectTo } from '../utils'\nimport { isValidEmail } from '../utils/validators'\n\nexport type SendVerificationEmailContext = {\n  error: AuthErrorPayload | null\n}\n\nexport type SendVerificationEmailEvents =\n  | {\n      type: 'REQUEST'\n      email?: string\n      options?: SendVerificationEmailOptions\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: AuthErrorPayload | null }\n\nexport type SendVerificationEmailServices = {\n  request: { data: SendVerificationEmailResponse }\n}\n\nexport type SendVerificationEmailMachine = ReturnType<typeof createSendVerificationEmailMachine>\nexport const createSendVerificationEmailMachine = ({ backendUrl, clientUrl }: AuthClient) => {\n  return createMachine(\n    {\n      schema: {\n        context: {} as SendVerificationEmailContext,\n        events: {} as SendVerificationEmailEvents,\n        services: {} as SendVerificationEmailServices\n      },\n      tsTypes: {} as import('./send-verification-email.typegen').Typegen0,\n      predictableActionArguments: true,\n      id: 'sendVerificationEmail',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidEmail',\n                actions: 'saveInvalidEmailError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'request',\n            id: 'request',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidEmail: (_, { email }) => !isValidEmail(email)\n      },\n      services: {\n        request: async (_, { email, options }) => {\n          const res = await postFetch<SendVerificationEmailResponse>(\n            `${backendUrl}/user/email/send-verification-email`,\n            { email, options: rewriteRedirectTo(clientUrl, options) }\n          )\n          return res.data\n        }\n      }\n    }\n  )\n}\n","import { interpret } from 'xstate'\nimport {\n  AuthContext,\n  AuthInterpreter,\n  AuthMachine,\n  AuthMachineOptions,\n  createAuthMachine\n} from './machines'\nimport { NhostSession } from './types'\nimport { isBrowser } from './utils'\n\nexport type NhostClientOptions = AuthMachineOptions & {\n  /** @internal create and start xstate interpreter on creation. With React, it is started inside the Nhost provider */\n  start?: boolean\n}\n\n/**\n * @internal\n * This is a private API.\n */\nexport class AuthClient {\n  readonly backendUrl: string\n  readonly clientUrl: string\n  private _machine: AuthMachine\n  private _interpreter?: AuthInterpreter\n  private _started = false\n  private _channel?: BroadcastChannel\n  private _subscriptionsQueue: Set<(client: AuthClient) => void> = new Set()\n  private _subscriptions: Set<() => void> = new Set()\n\n  constructor({\n    clientStorageType = 'web',\n    autoSignIn = true,\n    autoRefreshToken = true,\n    start = true,\n    backendUrl,\n    clientUrl,\n    devTools,\n    ...defaultOptions\n  }: NhostClientOptions) {\n    this.backendUrl = backendUrl\n    this.clientUrl = clientUrl\n\n    this._machine = createAuthMachine({\n      ...defaultOptions,\n      backendUrl,\n      clientUrl,\n      clientStorageType,\n      autoSignIn,\n      autoRefreshToken\n    })\n\n    if (start) {\n      this.start({ devTools })\n    }\n\n    if (typeof window !== 'undefined') {\n      try {\n        // TODO the same refresh token is used and refreshed by all tabs\n        // * Ideally, a single tab should autorefresh and share the new jwt\n        this._channel = new BroadcastChannel('nhost')\n\n        if (autoSignIn) {\n          this._channel?.addEventListener('message', (event) => {\n            const { type, payload } = event.data\n\n            if (type === 'broadcast_token') {\n              const existingToken = this.interpreter?.getSnapshot().context.refreshToken.value\n              if (this.interpreter && payload.token && payload.token !== existingToken) {\n                this.interpreter.send('TRY_TOKEN', { token: payload.token })\n              }\n            }\n          })\n        }\n\n        this._channel.addEventListener('message', (event) => {\n          const { type } = event.data\n\n          if (type === 'signout') {\n            if (this.interpreter) {\n              this.interpreter.send('SIGNOUT')\n            }\n          }\n        })\n      } catch (error) {\n        // * BroadcastChannel is not available e.g. react-native\n      }\n    }\n  }\n\n  start({\n    devTools = false,\n    initialSession,\n    interpreter\n  }: { interpreter?: AuthInterpreter; initialSession?: NhostSession; devTools?: boolean } = {}) {\n    // Create a deep copy of the machine context to ensure that nested objects (such as accessToken and refreshToken) are not mutated in the original context.\n    const context: AuthContext = {\n      ...this.machine.context,\n      accessToken: {\n        ...this.machine.context.accessToken\n      },\n      refreshToken: {\n        ...this.machine.context.refreshToken\n      }\n    }\n\n    if (initialSession) {\n      context.user = initialSession.user\n      context.refreshToken.value = initialSession.refreshToken ?? null\n      context.accessToken.value = initialSession.accessToken ?? null\n      context.accessToken.expiresAt = new Date(\n        Date.now() + initialSession.accessTokenExpiresIn * 1_000\n      )\n    }\n    const machineWithInitialContext = this.machine.withContext(context)\n\n    if (!this._interpreter) {\n      this._interpreter = interpreter || interpret(machineWithInitialContext, { devTools })\n    }\n\n    // * Start the interpreter if not started already. Always restart the interpreter when on the server side\n    if (!this._started || typeof window === 'undefined') {\n      if (this._interpreter.initialized) {\n        this._interpreter.stop()\n        this._subscriptions.forEach((fn) => fn())\n      }\n      this._interpreter.start(machineWithInitialContext.initialState)\n      this._subscriptionsQueue.forEach((fn) => fn(this))\n    }\n\n    this._started = true\n  }\n\n  public get machine() {\n    return this._machine\n  }\n\n  get interpreter(): AuthInterpreter | undefined {\n    return this._interpreter\n  }\n\n  get started(): boolean {\n    return this._started\n  }\n\n  subscribe(fn: (client: AuthClient) => () => void): () => void {\n    if (this.started) {\n      // * The interpreter is already available: we can add the listener straight ahead\n      const subscription = fn(this)\n      this._subscriptions.add(subscription)\n      return subscription\n    } else {\n      // * The interpreter is not yet available: we add the listener to a queue that will be started when setting the interpreter\n      // * Note: in React, the Xstate interpreter does not start from the global state, but from the root component\n      this._subscriptionsQueue.add(fn)\n      return () => {\n        console.log(\n          'onTokenChanged was added before the interpreter started. Cannot unsubscribe listener.'\n        )\n      }\n    }\n  }\n}\n\n/** @deprecated Not in use anymore. Use `clientStorageType: 'cookie'` instead */\nexport class AuthCookieClient extends AuthClient {\n  constructor({\n    ...options\n  }: Omit<\n    NhostClientOptions,\n    'clientStorageGetter' | 'clientStorageSetter' | 'clientStorage' | 'clientStorageType'\n  >) {\n    super({\n      ...options,\n      autoSignIn: isBrowser() && options.autoSignIn,\n      autoRefreshToken: isBrowser() && options.autoRefreshToken,\n      clientStorageType: 'cookie'\n    })\n  }\n}\n\n/** @deprecated Alias for {@link AuthCookieClient} */\nexport const AuthClientSSR = AuthCookieClient\n","import { startRegistration } from '@simplewebauthn/browser'\nimport {\n  PublicKeyCredentialCreationOptionsJSON,\n  RegistrationCredentialJSON\n} from '@simplewebauthn/typescript-types'\nimport { postFetch } from '..'\nimport { CodifiedError } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, SecurityKey } from '../types'\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\n\nexport interface AddSecurityKeyHandlerResult extends AuthActionErrorState, AuthActionSuccessState {\n  key?: SecurityKey\n}\n\nexport interface AddSecurityKeyState extends AddSecurityKeyHandlerResult, AuthActionLoadingState {}\n\nexport const addSecurityKeyPromise = async (\n  { backendUrl, interpreter }: AuthClient,\n  nickname?: string\n): Promise<AddSecurityKeyHandlerResult> => {\n  try {\n    const { data: options } = await postFetch<PublicKeyCredentialCreationOptionsJSON>(\n      `${backendUrl}/user/webauthn/add`,\n      {},\n      interpreter?.getSnapshot().context.accessToken.value\n    )\n    let credential: RegistrationCredentialJSON\n    try {\n      credential = await startRegistration(options)\n    } catch (e) {\n      throw new CodifiedError(e as Error)\n    }\n    const { data: key } = await postFetch<SecurityKey>(\n      `${backendUrl}/user/webauthn/verify`,\n      { credential, nickname },\n      interpreter?.getSnapshot().context.accessToken.value\n    )\n    return { key, isError: false, error: null, isSuccess: true }\n  } catch (e) {\n    const { error } = e as { error: AuthErrorPayload }\n    return { isError: true, error, isSuccess: false }\n  }\n}\n","import { InterpreterFrom } from 'xstate'\n\nimport { ChangeEmailMachine } from '../machines'\nimport { ChangeEmailOptions } from '../types'\n\nimport { AuthActionErrorState, AuthActionLoadingState, NeedsEmailVerificationState } from './types'\nexport interface ChangeEmailHandlerResult\n  extends AuthActionErrorState,\n    NeedsEmailVerificationState {}\n\nexport interface ChangeEmailState extends ChangeEmailHandlerResult, AuthActionLoadingState {}\n\nexport const changeEmailPromise = async (\n  interpreter: InterpreterFrom<ChangeEmailMachine>,\n  email: string,\n  options?: ChangeEmailOptions\n): Promise<ChangeEmailHandlerResult> =>\n  new Promise<ChangeEmailHandlerResult>((resolve) => {\n    interpreter.send('REQUEST', {\n      email,\n      options\n    })\n    interpreter.onTransition((s) => {\n      if (s.matches({ idle: 'error' })) {\n        resolve({ error: s.context.error, isError: true, needsEmailVerification: false })\n      } else if (s.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, needsEmailVerification: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { ChangePasswordMachine } from '../machines'\n\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\n\nexport interface ChangePasswordState extends ChangePasswordHandlerResult, AuthActionLoadingState {}\n\nexport interface ChangePasswordHandlerResult extends AuthActionErrorState, AuthActionSuccessState {}\n\nexport const changePasswordPromise = async (\n  interpreter: InterpreterFrom<ChangePasswordMachine>,\n  password: string,\n  ticket?: string\n): Promise<ChangePasswordHandlerResult> =>\n  new Promise<ChangePasswordHandlerResult>((resolve) => {\n    interpreter.send('REQUEST', {\n      password,\n      ticket\n    })\n    interpreter.onTransition((state) => {\n      if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isError: true, isSuccess: false })\n      } else if (state.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, isSuccess: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { EnableMfadMachine } from '../machines'\n\nimport { AuthActionErrorState } from './types'\n\nexport interface GenerateQrCodeHandlerResult extends AuthActionErrorState {\n  qrCodeDataUrl: string\n  isGenerated: boolean\n}\n\nexport interface GenerateQrCodeState extends GenerateQrCodeHandlerResult {\n  isGenerating: boolean\n}\nexport interface ActivateMfaHandlerResult extends AuthActionErrorState {\n  isActivated: boolean\n}\n\nexport interface ActivateMfaState extends ActivateMfaHandlerResult {\n  isActivating: boolean\n}\n\nexport const generateQrCodePromise = (service: InterpreterFrom<EnableMfadMachine>) =>\n  new Promise<GenerateQrCodeHandlerResult>((resolve) => {\n    service.send('GENERATE')\n    service.onTransition((state) => {\n      if (state.matches('generated')) {\n        resolve({\n          error: null,\n          isError: false,\n          isGenerated: true,\n          qrCodeDataUrl: state.context.imageUrl || ''\n        })\n      } else if (state.matches({ idle: 'error' })) {\n        resolve({\n          error: state.context.error || null,\n          isError: true,\n          isGenerated: false,\n          qrCodeDataUrl: ''\n        })\n      }\n    })\n  })\nexport const activateMfaPromise = (service: InterpreterFrom<EnableMfadMachine>, code: string) =>\n  new Promise<ActivateMfaHandlerResult>((resolve) => {\n    service.send('ACTIVATE', {\n      activeMfaType: 'totp',\n      code\n    })\n    service.onTransition((state) => {\n      if (state.matches({ generated: 'activated' })) {\n        resolve({ error: null, isActivated: true, isError: false })\n      } else if (state.matches({ generated: { idle: 'error' } })) {\n        resolve({ error: state.context.error, isActivated: false, isError: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { ResetPasswordMachine } from '../machines'\nimport { ResetPasswordOptions } from '../types'\n\nimport { AuthActionErrorState, AuthActionLoadingState } from './types'\n\nexport interface ResetPasswordHandlerResult extends AuthActionErrorState {\n  /** Returns `true` when an email to reset the password has been sent */\n  isSent: boolean\n}\n\nexport interface ResetPasswordState extends ResetPasswordHandlerResult, AuthActionLoadingState {}\n\nexport const resetPasswordPromise = async (\n  interpreter: InterpreterFrom<ResetPasswordMachine>,\n  email: string,\n  options?: ResetPasswordOptions\n): Promise<ResetPasswordHandlerResult> =>\n  new Promise((resolve) => {\n    interpreter.send('REQUEST', {\n      email,\n      options\n    })\n    interpreter.onTransition((state) => {\n      if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isError: true, isSent: false })\n      } else if (state.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, isSent: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { SendVerificationEmailMachine } from '../machines'\nimport { SendVerificationEmailOptions } from '../types'\n\nimport { AuthActionErrorState, AuthActionLoadingState } from './types'\n\nexport interface SendVerificationEmailHandlerResult extends AuthActionErrorState {\n  /** Returns `true` when a new verification email has been sent */\n  isSent: boolean\n}\n\nexport interface SendVerificationEmailState\n  extends AuthActionLoadingState,\n    SendVerificationEmailHandlerResult {}\n\nexport const sendVerificationEmailPromise = (\n  interpreter: InterpreterFrom<SendVerificationEmailMachine>,\n  email: string,\n  options?: SendVerificationEmailOptions\n): Promise<SendVerificationEmailHandlerResult> =>\n  new Promise<SendVerificationEmailHandlerResult>((resolve) => {\n    interpreter.send('REQUEST', {\n      email,\n      options\n    })\n    interpreter.onTransition((state) => {\n      if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isError: true, isSent: false })\n      } else if (state.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, isSent: true })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport { AuthActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInAnonymousHandlerResult extends SessionActionHandlerResult {}\nexport interface SignInAnonymousState\n  extends SignInAnonymousHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInAnonymousPromise = (\n  interpreter: AuthInterpreter\n): Promise<SignInAnonymousHandlerResult> =>\n  new Promise((resolve) => {\n    const { changed } = interpreter.send('SIGNIN_ANONYMOUS')\n    if (!changed) {\n      resolve({\n        isSuccess: false,\n        isError: true,\n        error: USER_ALREADY_SIGNED_IN,\n        user: null,\n        accessToken: null,\n        refreshToken: null\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          isSuccess: true,\n          isError: false,\n          error: null,\n          user: state.context.user,\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value\n        })\n      }\n      if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          isSuccess: false,\n          isError: true,\n          error: state.context.errors.authentication || null,\n          user: null,\n          accessToken: null,\n          refreshToken: null\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport {\n  AuthActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignInEmailPasswordHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {\n  needsMfaOtp: boolean\n  mfa: {\n    ticket: string\n  } | null\n}\n\nexport interface SignInEmailPasswordState\n  extends SignInEmailPasswordHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInEmailPasswordPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  password: string\n) =>\n  new Promise<SignInEmailPasswordHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNIN_PASSWORD', {\n      email,\n      password\n    })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        refreshToken: context.refreshToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        needsMfaOtp: false,\n        mfa: null,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          needsMfaOtp: false,\n          mfa: null,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'needsMfa' } })) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: false,\n          needsMfaOtp: true,\n          mfa: state.context.mfa,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          needsMfaOtp: false,\n          mfa: null,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          needsMfaOtp: false,\n          mfa: null,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\nimport { PasswordlessOptions } from '../types'\n\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\nexport interface SignInEmailPasswordlessHandlerResult\n  extends AuthActionErrorState,\n    AuthActionSuccessState {}\nexport interface SignInEmailPasswordlessState\n  extends SignInEmailPasswordlessHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInEmailPasswordlessPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  options?: PasswordlessOptions\n) =>\n  new Promise<SignInEmailPasswordlessHandlerResult>((resolve) => {\n    const { changed } = interpreter.send('PASSWORDLESS_EMAIL', {\n      email,\n      options\n    })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false\n        })\n      } else if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({ error: null, isError: false, isSuccess: true })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport {\n  AuthActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignInSecurityKeyPasswordlessHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignInSecurityKeyPasswordlessState\n  extends SignInSecurityKeyPasswordlessHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInEmailSecurityKeyPromise = (interpreter: AuthInterpreter, email: string) =>\n  new Promise<SignInSecurityKeyPasswordlessHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send({ type: 'SIGNIN_SECURITY_KEY_EMAIL', email })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        refreshToken: context.refreshToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import {\n  AuthenticationCredentialJSON,\n  PublicKeyCredentialRequestOptionsJSON\n} from '@simplewebauthn/typescript-types'\nimport {\n  AuthActionErrorState,\n  AuthActionSuccessState,\n  AuthClient,\n  AuthErrorPayload,\n  CodifiedError,\n  postFetch,\n  SignInResponse\n} from '..'\nimport { startAuthentication } from '@simplewebauthn/browser'\n\nexport interface ElevateWithSecurityKeyHandlerResult\n  extends AuthActionSuccessState,\n    AuthActionErrorState {\n  elevated: boolean\n}\n\nexport const elevateEmailSecurityKeyPromise = (authClient: AuthClient, email: string) =>\n  new Promise<ElevateWithSecurityKeyHandlerResult>(async (resolve) => {\n    const snapshot = authClient.interpreter?.getSnapshot()\n    const accessToken = snapshot?.context.accessToken.value\n\n    const { data } = await postFetch<PublicKeyCredentialRequestOptionsJSON>(\n      `${authClient.backendUrl}/elevate/webauthn`,\n      {\n        email\n      },\n      accessToken\n    )\n\n    let credential: AuthenticationCredentialJSON\n\n    try {\n      credential = await startAuthentication(data)\n    } catch (e) {\n      throw new CodifiedError(e as Error)\n    }\n\n    try {\n      const {\n        data: { session },\n        error: signInError\n      } = await postFetch<SignInResponse>(\n        `${authClient.backendUrl}/elevate/webauthn/verify`,\n        {\n          email,\n          credential\n        },\n        accessToken\n      )\n\n      if (session && !signInError) {\n        authClient.interpreter?.send({\n          type: 'SESSION_UPDATE',\n          data: {\n            session\n          }\n        })\n\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: true,\n          elevated: true\n        })\n      }\n    } catch (e) {\n      const { error } = e as { error: AuthErrorPayload }\n\n      resolve({\n        error,\n        isError: true,\n        isSuccess: false,\n        elevated: false\n      })\n    }\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport { AuthActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInMfaTotpHandlerResult extends SessionActionHandlerResult {}\n\nexport interface SignInMfaTotpState extends SignInMfaTotpHandlerResult, AuthActionLoadingState {}\n\nexport const signInMfaTotpPromise = (interpreter: AuthInterpreter, otp: string, ticket?: string) =>\n  new Promise<SignInMfaTotpHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNIN_MFA_TOTP', {\n      otp,\n      ticket\n    })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        refreshToken: context.refreshToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport { AuthActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInPATHandlerResult extends SessionActionHandlerResult {}\nexport interface SignInPATState extends SignInPATHandlerResult, AuthActionLoadingState {}\n\nexport const signInPATPromise = (\n  interpreter: AuthInterpreter,\n  pat: string\n): Promise<SignInPATHandlerResult> =>\n  new Promise((resolve) => {\n    const { changed } = interpreter.send('SIGNIN_PAT', { pat })\n\n    if (!changed) {\n      resolve({\n        isSuccess: false,\n        isError: true,\n        error: USER_ALREADY_SIGNED_IN,\n        user: null,\n        accessToken: null,\n        refreshToken: null\n      })\n    }\n\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        return resolve({\n          accessToken: null,\n          refreshToken: null,\n          user: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false\n        })\n      }\n\n      if (state.matches({ authentication: 'signedIn' })) {\n        return resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          user: state.context.user,\n          error: null,\n          isError: false,\n          isSuccess: true\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\nimport { PasswordlessOptions } from '../types'\n\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\n\nexport interface SignInSmsPasswordlessState\n  extends SignInSmsPasswordlessHandlerResult,\n    AuthActionLoadingState {}\n\nexport interface SignInSmsPasswordlessHandlerResult\n  extends AuthActionErrorState,\n    AuthActionSuccessState {\n  /**\n   * Returns true when the one-time password has been sent over by SMS, and the user needs to send it back to complete sign-in.\n   */\n  needsOtp: boolean\n}\n\nexport const signInSmsPasswordlessPromise = (\n  interpreter: AuthInterpreter,\n  phoneNumber: string,\n  options?: PasswordlessOptions\n) =>\n  new Promise<SignInSmsPasswordlessHandlerResult>((resolve) => {\n    const { changed } = interpreter.send('PASSWORDLESS_SMS', { phoneNumber, options })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsOtp: false\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.needsOtp')) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsOtp: true\n        })\n      } else if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsOtp: false\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport { AuthActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInSmsPasswordlessOtpHandlerResult extends SessionActionHandlerResult {}\nexport interface SignInSmsPasswordlessOtpState\n  extends SignInSmsPasswordlessOtpHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInSmsPasswordlessOtpPromise = (\n  interpreter: AuthInterpreter,\n  phoneNumber: string,\n  otp: string\n) =>\n  new Promise<SignInSmsPasswordlessOtpHandlerResult>((resolve) => {\n    const { changed } = interpreter.send({ type: 'PASSWORDLESS_SMS_OTP', phoneNumber, otp })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        user: null,\n        accessToken: null,\n        refreshToken: null\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: true,\n          user: state.context.user,\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value\n        })\n      } else if (state.matches({ registration: { incomplete: 'failed' } })) {\n        resolve({\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          user: null,\n          accessToken: null,\n          refreshToken: null\n        })\n      }\n    })\n  })\n","import { USER_UNAUTHENTICATED } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\n\nexport interface SignOutlessHandlerResult extends AuthActionErrorState, AuthActionSuccessState {}\nexport interface SignOutlessState extends SignOutlessHandlerResult, AuthActionLoadingState {}\n\nexport const signOutPromise = async (\n  interpreter: AuthInterpreter,\n  all?: boolean\n): Promise<SignOutlessHandlerResult> =>\n  new Promise<SignOutlessHandlerResult>((resolve) => {\n    const { event } = interpreter.send('SIGNOUT', { all })\n    if (event.type !== 'SIGNED_OUT') {\n      return resolve({ isSuccess: false, isError: true, error: USER_UNAUTHENTICATED })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: { signedOut: 'success' } })) {\n        resolve({ isSuccess: true, isError: false, error: null })\n      } else if (state.matches('authentication.signedOut.failed')) {\n        resolve({ isSuccess: false, isError: true, error: state.context.errors.signout || null })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\nimport { SignUpOptions } from '../types'\n\nimport {\n  AuthActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignUpEmailPasswordHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignUpEmailPasswordState\n  extends SignUpEmailPasswordHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signUpEmailPasswordPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  password: string,\n  options?: SignUpOptions\n): Promise<SignUpEmailPasswordHandlerResult> =>\n  new Promise<SignUpEmailPasswordHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNUP_EMAIL_PASSWORD', {\n      email,\n      password,\n      options\n    })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        accessToken: context.accessToken.value,\n        refreshToken: context.refreshToken.value,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn', registration: 'complete' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\nimport { SignUpSecurityKeyOptions } from '../types'\n\nimport {\n  AuthActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignUpSecurityKeyHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignUpSecurityKeyState\n  extends SignUpSecurityKeyHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signUpEmailSecurityKeyPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  options?: SignUpSecurityKeyOptions\n): Promise<SignUpSecurityKeyHandlerResult> =>\n  new Promise<SignUpSecurityKeyHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNUP_SECURITY_KEY', {\n      email,\n      options\n    })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        accessToken: context.accessToken.value,\n        refreshToken: context.refreshToken.value,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn', registration: 'complete' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, PersonalAccessTokenCreationResponse } from '../types'\nimport { postFetch } from '../utils/fetch'\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\n\nexport interface CreatePATHandlerParams {\n  /**\n   * The expiration date of the personal access token.\n   */\n  expiresAt: Date\n  /**\n   * Optional metadata to attach to the personal access token.\n   */\n  metadata?: Record<string, string | number>\n}\n\nexport interface CreatePATHandlerResult extends AuthActionErrorState, AuthActionSuccessState {\n  /**\n   * The data returned by the backend.\n   */\n  data?: {\n    /**\n     * The ID of the personal access token that was created.\n     */\n    id?: string | null\n    /**\n     * The personal access token that was created.\n     */\n    personalAccessToken?: string | null\n  } | null\n}\n\nexport interface CreatePATState extends CreatePATHandlerResult, AuthActionLoadingState {}\n\nexport const createPATPromise = async (\n  { backendUrl, interpreter }: AuthClient,\n  { expiresAt, metadata }: CreatePATHandlerParams\n): Promise<CreatePATHandlerResult> => {\n  try {\n    const { data } = await postFetch<PersonalAccessTokenCreationResponse>(\n      `${backendUrl}/pat`,\n      { expiresAt: expiresAt.toISOString(), metadata },\n      interpreter?.getSnapshot().context.accessToken.value\n    )\n\n    return {\n      data: data\n        ? {\n            id: data.id || null,\n            personalAccessToken: data.personalAccessToken || null\n          }\n        : null,\n      isError: false,\n      error: null,\n      isSuccess: true\n    }\n  } catch (e) {\n    const { error } = e as { error: AuthErrorPayload }\n    return { isError: true, error, isSuccess: false, data: null }\n  }\n}\n","import { jwtDecode } from 'jwt-decode'\nimport { interpret } from 'xstate'\nimport {\n  EMAIL_NEEDS_VERIFICATION,\n  INVALID_REFRESH_TOKEN,\n  INVALID_SIGN_IN_METHOD,\n  NO_REFRESH_TOKEN,\n  TOKEN_REFRESHER_RUNNING_ERROR\n} from './errors'\nimport { AuthClient } from './internal-client'\nimport {\n  AuthInterpreter,\n  createChangeEmailMachine,\n  createChangePasswordMachine,\n  createResetPasswordMachine,\n  createSendVerificationEmailMachine\n} from './machines'\nimport {\n  addSecurityKeyPromise,\n  changeEmailPromise,\n  changePasswordPromise,\n  elevateEmailSecurityKeyPromise,\n  resetPasswordPromise,\n  sendVerificationEmailPromise,\n  signInAnonymousPromise,\n  signInEmailPasswordlessPromise,\n  signInEmailPasswordPromise,\n  signInEmailSecurityKeyPromise,\n  signInMfaTotpPromise,\n  signInPATPromise,\n  signInSmsPasswordlessOtpPromise,\n  signInSmsPasswordlessPromise,\n  signOutPromise,\n  signUpEmailPasswordPromise,\n  signUpEmailSecurityKeyPromise\n} from './promises'\nimport { createPATPromise } from './promises/createPAT'\nimport {\n  AuthChangedFunction,\n  AuthErrorPayload,\n  ChangeEmailParams,\n  ChangeEmailResponse,\n  ChangePasswordParams,\n  ChangePasswordResponse,\n  ConnectProviderParams,\n  ConnectProviderResponse,\n  DeanonymizeParams,\n  DeanonymizeResponse,\n  JWTClaims,\n  JWTHasuraClaims,\n  NhostAuthConstructorParams,\n  NhostSessionResponse,\n  OnTokenChangedFunction,\n  ResetPasswordParams,\n  ResetPasswordResponse,\n  SecurityKey,\n  SendVerificationEmailParams,\n  SendVerificationEmailResponse,\n  SignInParams,\n  SignInPATResponse,\n  SignInResponse,\n  SignOutResponse,\n  SignUpParams,\n  SignUpResponse\n} from './types'\nimport {\n  encodeQueryParameters,\n  getAuthenticationResult,\n  getSession,\n  isBrowser,\n  rewriteRedirectTo\n} from './utils'\n\n/**\n * @alias Auth\n */\nexport class HasuraAuthClient {\n  private _client: AuthClient\n  readonly url: string\n  constructor({\n    url,\n    autoRefreshToken = true,\n    autoSignIn = true,\n    clientStorage,\n    clientStorageType,\n    refreshIntervalTime,\n    start = true\n  }: NhostAuthConstructorParams) {\n    this.url = url\n    this._client = new AuthClient({\n      backendUrl: url,\n      clientUrl: (typeof window !== 'undefined' && window.location?.origin) || '',\n      autoRefreshToken,\n      autoSignIn,\n      start,\n      clientStorage,\n      clientStorageType,\n      refreshIntervalTime\n    })\n  }\n\n  /**\n   * Use `nhost.auth.signUp` to sign up a user using email and password. If you want to sign up a user using passwordless email (Magic Link), SMS, or an OAuth provider, use the `signIn` function instead.\n   *\n   * @example\n   * ### Sign up with an email and password\n   * ```ts\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign up with a security key\n   * ```ts\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   securityKey: true\n   * })\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-up\n   */\n  async signUp(params: SignUpParams): Promise<SignUpResponse> {\n    const interpreter = await this.waitUntilReady()\n    const { email, options } = params\n    if ('securityKey' in params) {\n      return getAuthenticationResult(\n        await signUpEmailSecurityKeyPromise(interpreter, email, options)\n      )\n    }\n    return getAuthenticationResult(\n      await signUpEmailPasswordPromise(interpreter, email, params.password, options)\n    )\n  }\n\n  /**\n   * Use `nhost.auth.connectProvider` to connect a social authentication provider to an existing user account\n   *\n   * @example\n   * ### Connect an authentication provider to an existing user account\n   * ```ts\n   * nhost.auth.connectProvider({\n   *   provider: 'github\n   *   options: {\n   *    redirectTo: window.location.href\n   *   }\n   * })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/connect-provider\n   */\n  async connectProvider(params: ConnectProviderParams): Promise<ConnectProviderResponse> {\n    const interpreter = await this.waitUntilReady()\n    const accessToken = interpreter.getSnapshot().context.accessToken.value\n\n    const { provider, options } = params\n\n    const providerUrl = encodeQueryParameters(\n      `${this._client.backendUrl}/signin/provider/${provider}`,\n      rewriteRedirectTo(this._client.clientUrl, {\n        ...options,\n        connect: accessToken\n      } as any)\n    )\n    if (isBrowser()) {\n      window.location.href = providerUrl\n    }\n\n    return { providerUrl }\n  }\n\n  /**\n   * Use `nhost.auth.signIn` to sign in a user using email and password, passwordless (email or sms) or an external provider. `signIn` can be used to sign in a user in various ways depending on the parameters.\n   *\n   * @example\n   * ### Sign in a user using email and password\n   * ```ts\n   * nhost.auth.signIn({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using an OAuth provider (e.g: Google or Facebook)\n   * ```ts\n   * nhost.auth.signIn({ provider: 'google' })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using passwordless email (Magic Link)\n   * ```ts\n   * nhost.auth.signIn({ email: 'joe@example.com' })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using passwordless SMS\n   * ```ts\n   * // [step 1/2] Passwordless sign in using SMS\n   * nhost.auth.signIn({ phoneNumber: '+11233213123' })\n   *\n   * // [step 2/2] Finish passwordless sign in using SMS (OTP)\n   * nhost.auth.signIn({ phoneNumber: '+11233213123', otp: '123456' })\n   * ```\n   *\n   * @example\n   * ### Sign in anonymously\n   * ```ts\n   * // Sign in anonymously\n   * nhost.auth.signIn()\n   *\n   * // Later in the application, the user can complete their registration\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign in with a security key\n   * ```ts\n   * nhost.auth.signIn({\n   *   email: 'joe@example.com',\n   *   securityKey: true\n   * })\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in\n   */\n  async signIn(\n    params?: SignInParams\n  ): Promise<SignInResponse & { providerUrl?: string; provider?: string }> {\n    const interpreter = await this.waitUntilReady()\n    // * Anonymous sign-in\n    if (!params) {\n      const anonymousResult = await signInAnonymousPromise(interpreter)\n      return { ...getAuthenticationResult(anonymousResult), mfa: null }\n    }\n\n    // * Sign in with a social provider (OAuth)\n    if ('provider' in params) {\n      const { provider, options } = params\n      const providerUrl = encodeQueryParameters(\n        `${this._client.backendUrl}/signin/provider/${provider}`,\n        rewriteRedirectTo(this._client.clientUrl, options as any)\n      )\n      if (isBrowser()) {\n        window.location.href = providerUrl\n      }\n      return { providerUrl, provider, session: null, mfa: null, error: null }\n    }\n\n    // * Email + password\n    if ('email' in params && 'password' in params) {\n      const res = await signInEmailPasswordPromise(interpreter, params.email, params.password)\n      if (res.needsEmailVerification) {\n        return { session: null, mfa: null, error: EMAIL_NEEDS_VERIFICATION }\n      }\n      if (res.needsMfaOtp) {\n        return {\n          session: null,\n          mfa: res.mfa,\n          error: null\n        }\n      }\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    if ('email' in params && 'securityKey' in params) {\n      if (params.securityKey !== true) {\n        throw Error('securityKey must be true')\n      }\n      const res = await signInEmailSecurityKeyPromise(interpreter, params.email)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    // * Passwordless Email (magic link)\n    if ('email' in params) {\n      const { email, options } = params\n      const { error } = await signInEmailPasswordlessPromise(interpreter, email, options)\n      return {\n        session: null,\n        mfa: null,\n        error\n      }\n    }\n\n    // * Passwordless SMS: [step 2/2] sign in using SMS OTP\n    if ('phoneNumber' in params && 'otp' in params) {\n      const res = await signInSmsPasswordlessOtpPromise(interpreter, params.phoneNumber, params.otp)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    // * Passwordless SMS: [step 1/2] sign in using SMS\n    if ('phoneNumber' in params) {\n      const { error } = await signInSmsPasswordlessPromise(\n        interpreter,\n        params.phoneNumber,\n        params.options\n      )\n      return { error, mfa: null, session: null }\n    }\n\n    // * Email + password MFA TOTP\n    if ('otp' in params) {\n      const res = await signInMfaTotpPromise(interpreter, params.otp, params.ticket)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    return { error: INVALID_SIGN_IN_METHOD, mfa: null, session: null }\n  }\n\n  /**\n   * Use `nhost.auth.signInPAT` to sign in with a personal access token (PAT).\n   *\n   * @example\n   * ```ts\n   * nhost.auth.signInPAT('34f74930-09c0-4af5-a8d5-28fad78e3415')\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in-pat\n   *\n   * @param personalAccessToken - The personal access token to sign in with\n   */\n  async signInPAT(personalAccessToken: string): Promise<SignInPATResponse> {\n    const interpreter = await this.waitUntilReady()\n    const res = await signInPATPromise(interpreter, personalAccessToken)\n\n    return getAuthenticationResult(res)\n  }\n\n  /**\n   * Use `nhost.auth.signOut` to sign out the user.\n   *\n   * @example\n   * ### Sign out the user from current device\n   * ```ts\n   * nhost.auth.signOut()\n   * ```\n   *\n   * @example\n   * ### Sign out the user from all devices\n   * ```ts\n   * nhost.auth.signOut({all: true})\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-out\n   */\n  async signOut(params?: { all?: boolean }): Promise<SignOutResponse> {\n    const interpreter = await this.waitUntilReady()\n    const { error } = await signOutPromise(interpreter, params?.all)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.resetPassword` to reset the password for a user. This will send a reset-password link in an email to the user. When the user clicks the reset-password link the user is automatically signed-in. Once signed-in, the user can change their password using `nhost.auth.changePassword()`.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.resetPassword({email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/reset-password\n   */\n  async resetPassword({ email, options }: ResetPasswordParams): Promise<ResetPasswordResponse> {\n    const service = interpret(createResetPasswordMachine(this._client)).start()\n    const { error } = await resetPasswordPromise(service, email, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.changePassword` to change the password for the signed-in user. The old password is not needed. In case the user is not signed-in, a password reset ticket needs to be provided.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.changePassword({ newPassword: 'new-secret-password' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/change-password\n   */\n  async changePassword({\n    newPassword,\n    ticket\n  }: ChangePasswordParams): Promise<ChangePasswordResponse> {\n    const service = interpret(createChangePasswordMachine(this._client)).start()\n    const { error } = await changePasswordPromise(service, newPassword, ticket)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.sendVerificationEmail` to send a verification email to the specified email. The email contains a verification-email link. When the user clicks the verification-email link their email is verified.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.sendVerificationEmail({ email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/send-verification-email\n   */\n  async sendVerificationEmail({\n    email,\n    options\n  }: SendVerificationEmailParams): Promise<SendVerificationEmailResponse> {\n    const service = interpret(createSendVerificationEmailMachine(this._client)).start()\n    const { error } = await sendVerificationEmailPromise(service, email, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.changeEmail` to change a user's email. This will send a confirm-email-change link in an email to the new email. Once the user clicks on the confirm-email-change link the email will be change to the new email.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.changeEmail({ newEmail: 'doe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/change-email\n   */\n  async changeEmail({ newEmail, options }: ChangeEmailParams): Promise<ChangeEmailResponse> {\n    const service = interpret(createChangeEmailMachine(this._client)).start()\n    const { error } = await changeEmailPromise(service, newEmail, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.deanonymize` to deanonymize a user.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.deanonymize({signInMethod: 'email-password', email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/deanonymize\n   */\n  async deanonymize(params: DeanonymizeParams): Promise<DeanonymizeResponse> {\n    const interpreter = await this.waitUntilReady()\n    if (params.signInMethod === 'passwordless') {\n      if (params.connection === 'email') {\n        const { error } = await signInEmailPasswordlessPromise(\n          interpreter,\n          params.email,\n          params.options\n        )\n        return { error }\n      }\n      if (params.connection === 'sms') {\n        const { error } = await signInSmsPasswordlessPromise(\n          interpreter,\n          params.phoneNumber,\n          params.options\n        )\n        return { error }\n      }\n    }\n    if (params.signInMethod === 'email-password') {\n      const { error } = await signUpEmailPasswordPromise(\n        interpreter,\n        params.email,\n        params.password,\n        params.options\n      )\n      return { error }\n    }\n    throw Error(`Unknown deanonymization method`)\n  }\n\n  /**\n   * Use `nhost.auth.addSecurityKey` to add a security key to the user, using the WebAuthn API.\n   * @param nickname optional human-readable nickname for the security key\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/add-security-key\n   */\n  async addSecurityKey(\n    nickname?: string\n  ): Promise<{ error: AuthErrorPayload | null; key?: SecurityKey }> {\n    const { error, key } = await addSecurityKeyPromise(this._client, nickname)\n    return { error, key }\n  }\n\n  /**\n   * Use `nhost.auth.elevateEmailSecurityKey` to get a temporary elevated auth permissions to run sensitive operations.\n   * @param email user email\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/elevate-email-security-key\n   */\n  async elevateEmailSecurityKey(email: string) {\n    if (!email) {\n      throw Error('A user email is required')\n    }\n\n    const res = await elevateEmailSecurityKeyPromise(this._client, email)\n\n    return { ...res, mfa: null }\n  }\n\n  /**\n   * Use `nhost.auth.createPAT` to create a personal access token for the user.\n   *\n   * @param expiresAt Expiration date for the token\n   * @param metadata Optional metadata to store with the token\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/create-pat\n   */\n  async createPAT(expiresAt: Date, metadata?: Record<string, string | number>) {\n    return createPATPromise(this._client, { expiresAt, metadata })\n  }\n\n  /**\n   * Use `nhost.auth.onTokenChanged` to add a custom function that runs every time the access or refresh token is changed.\n   *\n   *\n   * @example\n   * ```ts\n   * nhost.auth.onTokenChanged(() => console.log('The access and refresh token has changed'));\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/on-token-changed\n   */\n  onTokenChanged(fn: OnTokenChangedFunction): Function {\n    return this._client.subscribe(() => {\n      const subscription = this._client.interpreter?.onTransition(({ event, context }) => {\n        if (event.type === 'TOKEN_CHANGED') {\n          fn(getSession(context))\n        }\n      })\n      return () => subscription?.stop()\n    })\n  }\n\n  /**\n   * Use `nhost.auth.onAuthStateChanged` to add a custom function that runs every time the authentication status of the user changes. E.g. add a custom function that runs every time the authentication status changes from signed-in to signed-out.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.onAuthStateChanged((event, session) => {\n   *   console.log(`The auth state has changed. State is now ${event} with session: ${session}`)\n   * });\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/on-auth-state-changed\n   */\n  onAuthStateChanged(fn: AuthChangedFunction): Function {\n    return this._client.subscribe(() => {\n      const subscription = this._client.interpreter?.onTransition(({ event, context }) => {\n        if (event.type === 'SIGNED_IN' || event.type === 'SIGNED_OUT') {\n          fn(event.type, getSession(context))\n        }\n      })\n      return () => subscription?.stop()\n    })\n  }\n\n  /**\n   * Use `nhost.auth.isAuthenticated` to check if the user is authenticated or not.\n   *\n   * Note: `nhost.auth.isAuthenticated()` can return `false` for two reasons:\n   * 1. The user is not authenticated\n   * 2. The user is not authenticated but _might_ be authenticated soon (loading) because there is a network request in transit.\n   *\n   * Use `nhost.auth.getAuthenticationStatus` to get both authentication and loading status.\n   *\n   * @example\n   * ```ts\n   * const isAuthenticated = nhost.auth.isAuthenticated();\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated\n   */\n  isAuthenticated(): boolean {\n    return !!this._client.interpreter?.getSnapshot().matches({ authentication: 'signedIn' })\n  }\n\n  /**\n   * Use `nhost.auth.isAuthenticatedAsync` to wait (await) for any internal authentication network requests to finish and then return the authentication status.\n   *\n   * The promise won't resolve until the authentication status is known.\n   * Attention: when using auto-signin and a refresh token is present in the client storage, the promise won't resolve if the server can't be reached (e.g. offline) or if it returns an internal error.\n   *\n   * @example\n   * ```ts\n   * const isAuthenticated  = await nhost.auth.isAuthenticatedAsync();\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated-async\n   */\n  async isAuthenticatedAsync(): Promise<boolean> {\n    const interpreter = await this.waitUntilReady()\n    return interpreter.getSnapshot().matches({ authentication: 'signedIn' })\n  }\n\n  /**\n   * Use `nhost.auth.getAuthenticationStatus` to get the authentication status of the user.\n   *\n   * If `isLoading` is `true`, the client doesn't know whether the user is authenticated yet or not\n   * because some internal authentication network requests have not been resolved yet.\n   *\n   * The `connectionAttempts` returns the number of times the client has tried to connect to the server with no success (offline, or the server retruned an internal error).\n   *\n   * @example\n   * ```ts\n   * const { isAuthenticated, isLoading } = nhost.auth.getAuthenticationStatus();\n   *\n   * if (isLoading) {\n   *   console.log('Loading...')\n   * }\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-authentication-status\n   */\n  getAuthenticationStatus(): {\n    isAuthenticated: boolean\n    isLoading: boolean\n    connectionAttempts: number\n  } {\n    const connectionAttempts =\n      this.client.interpreter?.getSnapshot().context.importTokenAttempts || 0\n    if (!this.isReady()) {\n      return {\n        isAuthenticated: false,\n        isLoading: true,\n        connectionAttempts\n      }\n    }\n    return { isAuthenticated: this.isAuthenticated(), isLoading: false, connectionAttempts }\n  }\n\n  /**\n   * Use `nhost.auth.getAccessToken` to get the access token of the user.\n   *\n   * @example\n   * ```ts\n   * const accessToken = nhost.auth.getAccessToken();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-access-token\n   */\n  getAccessToken(): string | undefined {\n    return this._client.interpreter?.getSnapshot().context.accessToken.value ?? undefined\n  }\n\n  /**\n   * Use `nhost.auth.getDecodedAccessToken` to get the decoded access token of the user.\n   *\n   * @example\n   * ```ts\n   * const decodedAccessToken = nhost.auth.getDecodedAccessToken();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-decoded-access-token\n   */\n  public getDecodedAccessToken(): JWTClaims | null {\n    const jwt = this.getAccessToken()\n    if (!jwt) return null\n    return jwtDecode<JWTClaims>(jwt)\n  }\n\n  /**\n   * Use `nhost.auth.getHasuraClaims` to get the Hasura claims of the user.\n   *\n   * @example\n   * ```ts\n   * const hasuraClaims = nhost.auth.getHasuraClaims();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claims\n   */\n  public getHasuraClaims(): JWTHasuraClaims | null {\n    return this.getDecodedAccessToken()?.['https://hasura.io/jwt/claims'] || null\n  }\n\n  /**\n   * Use `nhost.auth.getHasuraClaim` to get the value of a specific Hasura claim of the user.\n   *\n   * @example\n   * ```ts\n   * // if `x-hasura-company-id` exists as a custom claim\n   * const companyId = nhost.auth.getHasuraClaim('company-id')\n   * ```\n   *\n   * @param name Name of the variable. You don't have to specify `x-hasura-`.\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claim\n   */\n  public getHasuraClaim(name: string): string | string[] | null {\n    return (\n      this.getHasuraClaims()?.[name.startsWith('x-hasura-') ? name : `x-hasura-${name}`] || null\n    )\n  }\n\n  /**\n   *\n   * Use `nhost.auth.refreshSession` to refresh the session with either the current internal refresh token or an external refresh token.\n   *\n   * Note: The Nhost client automatically refreshes the session when the user is authenticated but `nhost.auth.refreshSession` can be useful in some special cases.\n   *\n   * @example\n   * ```ts\n   * // Refresh the session with the the current internal refresh token.\n   * nhost.auth.refreshToken();\n   *\n   * // Refresh the session with an external refresh token.\n   * nhost.auth.refreshToken(refreshToken);\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/refresh-session\n   */\n  async refreshSession(refreshToken?: string): Promise<NhostSessionResponse> {\n    try {\n      const interpreter = await this.waitUntilReady()\n      return new Promise((resolve) => {\n        const token = refreshToken || interpreter.getSnapshot().context.refreshToken.value\n        if (!token) {\n          return resolve({ session: null, error: NO_REFRESH_TOKEN })\n        }\n        const { changed } = interpreter.send('TRY_TOKEN', { token })\n        if (!changed) {\n          return resolve({ session: null, error: TOKEN_REFRESHER_RUNNING_ERROR })\n        }\n        interpreter.onTransition((state) => {\n          if (state.matches({ token: { idle: 'error' } })) {\n            resolve({\n              session: null,\n              // * TODO get the error from xstate once it is implemented\n              error: INVALID_REFRESH_TOKEN\n            })\n          } else if (state.event.type === 'TOKEN_CHANGED') {\n            resolve({ session: getSession(state.context), error: null })\n          }\n        })\n      })\n    } catch (error: any) {\n      // TODO return error in the correct format\n      return { session: null, error: error.message }\n    }\n  }\n\n  /**\n   *\n   * Use `nhost.auth.getSession()` to get the session of the user.\n   *\n   * @example\n   * ```ts\n   * const session = nhost.auth.getSession();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-session\n   */\n  getSession() {\n    return getSession(this._client.interpreter?.getSnapshot()?.context)\n  }\n\n  /**\n   *\n   * Use `nhost.auth.getUser()` to get the signed-in user.\n   *\n   * @example\n   * ```ts\n   * const user = nhost.auth.getUser();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-user\n   */\n  getUser() {\n    return this._client.interpreter?.getSnapshot()?.context?.user || null\n  }\n\n  /**\n   * Make sure the state machine is set, and wait for it to be ready\n   * @returns\n   */\n  private waitUntilReady(): Promise<AuthInterpreter> {\n    const TIMEOUT_IN_SECONS = 15\n    const interpreter = this._client.interpreter\n    if (!interpreter) {\n      throw Error('Auth interpreter not set')\n    }\n    if (!interpreter.getSnapshot().hasTag('loading')) {\n      return Promise.resolve(interpreter)\n    }\n    return new Promise((resolve, reject) => {\n      let timer: ReturnType<typeof setTimeout> = setTimeout(\n        () => reject(`The state machine is not yet ready after ${TIMEOUT_IN_SECONS} seconds.`),\n        TIMEOUT_IN_SECONS * 1_000\n      )\n      interpreter.onTransition((state) => {\n        if (!state.hasTag('loading')) {\n          clearTimeout(timer)\n          return resolve(interpreter)\n        }\n      })\n    })\n  }\n\n  private isReady() {\n    return !this._client.interpreter?.getSnapshot()?.hasTag('loading')\n  }\n\n  get client() {\n    return this._client\n  }\n}\n"],"names":["NHOST_REFRESH_TOKEN_KEY","NHOST_REFRESH_TOKEN_ID_KEY","NHOST_JWT_EXPIRES_AT_KEY","MIN_PASSWORD_LENGTH","TOKEN_REFRESH_MARGIN_SECONDS","REFRESH_TOKEN_MAX_ATTEMPTS","NETWORK_ERROR_CODE","OTHER_ERROR_CODE","VALIDATION_ERROR_CODE","STATE_ERROR_CODE","CodifiedError","original","INVALID_EMAIL_ERROR","INVALID_MFA_TYPE_ERROR","INVALID_MFA_CODE_ERROR","INVALID_PASSWORD_ERROR","INVALID_PHONE_NUMBER_ERROR","INVALID_MFA_TICKET_ERROR","NO_MFA_TICKET_ERROR","NO_REFRESH_TOKEN","TOKEN_REFRESHER_RUNNING_ERROR","USER_ALREADY_SIGNED_IN","USER_UNAUTHENTICATED","USER_NOT_ANONYMOUS","EMAIL_NEEDS_VERIFICATION","INVALID_REFRESH_TOKEN","INVALID_SIGN_IN_METHOD","INITIAL_MACHINE_CONTEXT","utf8StringToBuffer","value","bufferToBase64URLString","buffer","bytes","str","charCode","base64URLStringToBuffer","base64URLString","base64","padLength","padded","binary","i","browserSupportsWebAuthn","toPublicKeyCredentialDescriptor","descriptor","id","isValidDomain","hostname","WebAuthnError","message","code","cause","name","identifyRegistrationError","error","options","publicKey","_a","_b","param","effectiveDomain","BaseWebAuthnAbortService","abortError","newController","WebAuthnAbortService","attachments","toAuthenticatorAttachment","attachment","startRegistration","creationOptionsJSON","credential","err","rawId","response","type","transports","responsePublicKeyAlgorithm","warnOnBrokenImplementation","responsePublicKey","_publicKey","responseAuthenticatorData","methodName","bufferToUTF8String","browserSupportsWebAuthnAutofill","globalPublicKeyCredential","resolve","identifyAuthenticationError","startAuthentication","requestOptionsJSON","useBrowserAutofill","allowCredentials","userHandle","isBrowser","inMemoryLocalStorage","defaultClientStorageGetter","key","defaultClientStorageSetter","localStorageGetter","clientStorageType","clientStorage","Cookies","localStorageSetter","getSession","context","getAuthenticationResult","accessToken","refreshToken","isError","user","fetch","fetchPonyfill","fetchWrapper","url","method","token","body","headers","result","postFetch","getFetch","encodeQueryParameters","baseUrl","parameters","encodedParameters","stringValue","rewriteRedirectTo","clientUrl","redirectTo","otherOptions","baseClientUrl","clientParams","additionalParams","combinedParams","pathName","getParameterByName","regex","results","removeParameterFromWindow","location","search","hash","isValidEmail","email","isValidPassword","password","isValidPhoneNumber","phoneNumber","isValidTicket","ticket","createAuthMachine","backendUrl","refreshIntervalTime","autoRefreshToken","autoSignIn","storageGetter","storageSetter","postRequest","data","createMachine","send","assign","importTokenAttempts","_","accessTokenExpiresIn","nextRefresh","refreshTokenId","e","ctx","errors","expiresAt","accessTokenExpirationTime","_context","pat","otp","event","signOutResponse","nickname","webAuthnOptions","urlToken","exception","errorDescription","storageToken","createChangeEmailMachine","interpreter","createChangePasswordMachine","createEnableMfaMachine","imageUrl","totpSecret","activeMfaType","createResetPasswordMachine","createSendVerificationEmailMachine","AuthClient","start","devTools","defaultOptions","payload","existingToken","initialSession","machineWithInitialContext","interpret","fn","subscription","AuthCookieClient","AuthClientSSR","addSecurityKeyPromise","changeEmailPromise","changePasswordPromise","state","generateQrCodePromise","service","activateMfaPromise","resetPasswordPromise","sendVerificationEmailPromise","signInAnonymousPromise","changed","signInEmailPasswordPromise","signInEmailPasswordlessPromise","signInEmailSecurityKeyPromise","elevateEmailSecurityKeyPromise","authClient","snapshot","session","signInError","signInMfaTotpPromise","signInPATPromise","signInSmsPasswordlessPromise","signInSmsPasswordlessOtpPromise","signOutPromise","all","signUpEmailPasswordPromise","signUpEmailSecurityKeyPromise","createPATPromise","metadata","HasuraAuthClient","params","provider","providerUrl","anonymousResult","res","personalAccessToken","newPassword","newEmail","connectionAttempts","jwt","jwtDecode","_c","reject","timer"],"mappings":"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","x_google_ignoreList":[3]}